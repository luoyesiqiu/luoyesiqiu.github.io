<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> x86平台inline hook原理和实现 · luoyesiqiu</title><meta name="description" content="x86平台inline hook原理和实现 - luoyesiqiu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://luoyesiqiu.github.io/atom.xml" title="luoyesiqiu"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="luoyesiqiu" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">luoyesiqiu</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/about/me" target="_self" class="li component-nav-item"><p>关于我</p></a><ul class="shortcut-icons"><a href="https://github.com/luoyesiqiu" target="_blank"><img src="/images/github.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">x86平台inline hook原理和实现</h1><div class="post-info">2021年4月3日</div><div class="post-content"><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>inline hook是一种通过修改机器码的方式来实现hook的技术。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>对于正常执行的程序，它的函数调用流程大概是这样的：</p>
<p><img src="/images/x86-inlinehook/normal-call.png"></p>
<p>0x1000地址的call指令执行后跳转到0x3000地址处执行，执行完毕后再返回执行call指令的下一条指令。</p>
<p>我们在hook的时候，可能会读取或者修改call指令执行之前所压入栈的内容。那么，我们可以将call指令<strong>替换</strong>成jmp指令，jmp到我们自己编写的函数，在函数里call原来的函数，函数结束后再jmp回到原先call指令的下一条指令。如图：</p>
<p><img src="/images/x86-inlinehook/inlinehook.png"></p>
<p>通过修改机器码实现的inline hook，不仅不会破坏原本的程序逻辑，而且还能执行我们的代码，读写被hook的函数的数据。</p>
<h2 id="inline-hook流程"><a href="#inline-hook流程" class="headerlink" title="inline hook流程"></a>inline hook流程</h2><h3 id="1-寻找hook位置"><a href="#1-寻找hook位置" class="headerlink" title="(1)寻找hook位置"></a>(1)寻找hook位置</h3><p>在逆向的时候，会遇到不同类型的call，它们所占的字节可能是不一样的，本文构造一个长度为5字节的jmp指令（jmp的机器码占用1字节，跳转到的地址偏移占用4字节）来替换原来的5字节的call指令。即我们需要寻找长度为5字节的call，来进行inline hook。5字节的call形如：</p>
<p><img src="/images/x86-inlinehook/callasm.png"></p>
<h3 id="2-inline-hook代码实现"><a href="#2-inline-hook代码实现" class="headerlink" title="(2)inline hook代码实现"></a>(2)inline hook代码实现</h3><p>在x86汇编中，同样有很多类型的jmp，本文构造inline hook使用的是近距离地址跳转的jmp指令，它的机器码为<code>E9</code>，这种类型的jmp指令需要一个参数，参数是<strong>当前jmp指令地址</strong>距离<strong>目标函数地址</strong>的字节数。</p>
<p>假设需要hook的call的指令的内存地址为：<code>0x1000</code>，我们想要它执行后跳转到我们的函数（假设函数在内存中的地址：<code>0x5000</code>），那么，构造jmp指令时，指令应为：</p>
<p><code>jmp (0x5000-(0x1000 + 5))</code>  </p>
<p>即：</p>
<p><code>jmp 0x3FFB</code></p>
<p>对于5字节指令的hook，上面的计算公式是固定的，jmp指令本身占用5字节，所以加上5</p>
<p>懂了这些知识，就可以动手编写hook代码了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StartHook</span><span class="params">(DWORD hookAddr, BYTE backCode[<span class="number">5</span>], <span class="keyword">void</span>(*FuncBeCall)())</span> </span>&#123;</span><br><span class="line">	DWORD jmpAddr = (DWORD)FuncBeCall - (hookAddr + <span class="number">5</span>);</span><br><span class="line">	BYTE jmpCode[<span class="number">5</span>];</span><br><span class="line">	*(jmpCode + <span class="number">0</span>) = <span class="number">0xE9</span>;</span><br><span class="line">	*(DWORD *)(jmpCode + <span class="number">1</span>) = jmpAddr;</span><br><span class="line">	HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ReadProcessMemory</span>(hProcess, (LPVOID)hookAddr, backCode, <span class="number">5</span> , <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WriteProcessMemory</span>(hProcess, (LPVOID)hookAddr, jmpCode, <span class="number">5</span>, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的StartHook函数，hookAddr接收一个将被替换的call指令的内存地址；backCode接收一个长度为5字节的数组缓冲区，用于备份原有的call指令；FuncBeCall参数接收一个返回值为void函数地址。</p>
<p>StartHook函数的逻辑是：根据FuncBeCall的地址计算jmp的地址，并构造一条完整的jmp指令，存入数组。我们要hook当前的进程，所以调用OpenProcess打开当前进程。调用ReadProcessMemory读取当前进程hookAddr处的指令，写入backCode数组。调用WriteProcessMemory将构造好的jmp指令写入当前进程hookAddr处。</p>
<p>StartHook函数第3个参数接收一个函数地址，这个函数地址指向的函数应该是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">OnCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnCall函数用<code>_declspec(naked)</code>修饰，被它修饰的函数我们常称它为裸函数，裸函数的特点是在编译生成的时候不会产生过多用于平衡堆栈的指令，这意味着在裸函数中我们要编写<strong>内联汇编</strong>控制堆栈平衡。一个比较简单写法是备份所有的寄存器，做完其他操作后再把寄存器的值还原回去，代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DWORD tEax = <span class="number">0</span>,tEcx = <span class="number">0</span>,tEdx = <span class="number">0</span>,tEbx = <span class="number">0</span>,tEsp = <span class="number">0</span>,tEbp = <span class="number">0</span>,tEsi = <span class="number">0</span>,tEdi = <span class="number">0</span>;</span><br><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">OnCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		mov tEax, eax</span><br><span class="line">		mov tEcx, ecx</span><br><span class="line">		mov tEdx, edx</span><br><span class="line">		mov tEbx, ebx</span><br><span class="line">		mov tEsp, esp</span><br><span class="line">		mov tEbp, ebp</span><br><span class="line">		mov tEsi, esi</span><br><span class="line">		mov tEdi, edi</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">	__asm &#123;</span><br><span class="line">		mov eax, tEax</span><br><span class="line">		mov ecx, tEcx</span><br><span class="line">		mov edx, tEdx</span><br><span class="line">		mov ebx, tEbx</span><br><span class="line">		mov esp, tEsp</span><br><span class="line">		mov ebp, tEbp</span><br><span class="line">		mov esi, tEsi</span><br><span class="line">		mov edi, tEdi</span><br><span class="line">		call ...</span><br><span class="line">		jmp ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>裸函数编写规则可以参考msdn上的<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/windows/desktop/4d12973a">这篇文档</a>。</p>
</blockquote>
<p>当我们替换到进程的jmp代码被执行，它就会跳转到该裸函数。在裸函数里，先备份所有的寄存器，然后编写我们的hook代码，编写hook代码时可以通过esp寄存器读取或者修改原call的参数，或者通过修改eax寄存器以修改原call的返回值，再或者调用其他函数等等。执行完我们的hook代码再把寄存器的值还原回去。这样就不会导致程序逻辑出错而崩溃。</p>
<p>但是，上面内联汇编代码的写法看起来似乎不太简洁，有更好的写法吗，答案是有的。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">OnCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	__asm &#123;</span><br><span class="line">	    pushad</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">	__asm &#123;</span><br><span class="line">	    popad</span><br><span class="line">	    call ...</span><br><span class="line">	    jmp ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看，是不是简洁多了。</p>
<p>上面代码中，pushad的作用是把8个通用寄存器入栈，相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">push EAX</span><br><span class="line">push ECX</span><br><span class="line">push EDX</span><br><span class="line">push EBX</span><br><span class="line">push ESP</span><br><span class="line">push EBP</span><br><span class="line">push ESI</span><br><span class="line">push EDI</span><br></pre></td></tr></table></figure>
<p>popad作用是把栈顶的8个元素出栈，再把它们传到相应的通用寄存器，出栈顺序与pushad指令的入栈顺序正好相反，相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pop EDI</span><br><span class="line">pop ESI</span><br><span class="line">pop EBP</span><br><span class="line">pop ESP</span><br><span class="line">pop EBX</span><br><span class="line">pop EDX</span><br><span class="line">pop ECX</span><br><span class="line">pop EAX</span><br></pre></td></tr></table></figure>
<p>使用pushad和popad指令，通用寄存器的数据就能方便的保存下来，也可以方便的还原回去。</p>
<h2 id="卸载inline-hook流程"><a href="#卸载inline-hook流程" class="headerlink" title="卸载inline hook流程"></a>卸载inline hook流程</h2><p>卸载hook的流程比较简单，也是打开当前进程，把hook时备份的call指令写回原来的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Unhook</span><span class="params">(DWORD hookAddr, BYTE backCode[<span class="number">5</span>])</span> </span>&#123;</span><br><span class="line">	HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WriteProcessMemory</span>(hProcess, (LPVOID)hookAddr, backCode, <span class="number">5</span>, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数hookAddr是原来hook的call的内存地址，参数backCode是原来备份下来的call指令。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是针对5字节的call进行inline hook，在寻找call的时候可能会遇到许多不同的call，比如6字节的call，或者7字节的call。对于不同的call，只要掌握了inline hook原理，就可以根据实际情况编写hook代码。</p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2021/04/03/Android-FART%E8%84%B1%E5%A3%B3%E6%9C%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" class="next">下一篇</a></div><div class="copyright"><p>© 2021 <a href="http://luoyesiqiu.github.io">luoyesiqiu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>