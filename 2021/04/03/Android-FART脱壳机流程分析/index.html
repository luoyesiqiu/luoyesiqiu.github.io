<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android FART脱壳机流程分析 · luoyesiqiu</title><meta name="description" content="Android FART脱壳机流程分析 - luoyesiqiu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://luoyesiqiu.github.io/atom.xml" title="luoyesiqiu"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="luoyesiqiu" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">luoyesiqiu</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/about/me" target="_self" class="li component-nav-item"><p>关于我</p></a><ul class="shortcut-icons"><a href="https://github.com/luoyesiqiu" target="_blank"><img src="/images/github.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">Android FART脱壳机流程分析</h1><div class="post-info">2021年4月3日</div><div class="post-content"><blockquote>
<p>本文首发于安全客</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/219094">https://www.anquanke.com/post/id/219094</a></p>
</blockquote>
<h2 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1 前言"></a>0x1 前言</h2><p>在Android平台上，程序员编写的Java代码最终将被编译成字节码在Android虚拟机上运行。自从Android进入大众的视野后，apktool,jadx等反编译工具也层出不穷，功能也越来越强大，由Java编译成的字节码在这些反编译工具面前变得不堪一击，这相当于一个人裸奔在茫茫人海，身体的各个部位被众人一览无余。一种事物的出现，也会有与之对立的事物出现。有反编译工具的出现，当然也会有反反编译工具的出现，这种技术一般我们加固技术。APP经过加固，就相当于给那个裸奔的人穿了衣服，“衣服”在一定程度上保护了APP，使APP没那么容易被反编译。当然，有加固技术的出现，也会有反加固技术的出现，即本文要分析的脱壳技术。</p>
<p>Android经过多个版本的更迭，它无论在外观还是内在都有许多改变，早期的Android使用的是dalvik虚拟机，Android4.4开始加入ART虚拟机，但不默认启用。从Android5.0开始，ART取代dalvik，成为默认虚拟机。由于dalvik和ART运行机制的不同，在它们内部脱壳原理也不太相同，本文分析的是ART下的脱壳方案：FART。它的整体思路是通过<strong>主动调用</strong>的方式来实现脱壳，项目地址：<a target="_blank" rel="noopener" href="https://github.com/hanbinglengyue/FART">https://github.com/hanbinglengyue/FART</a> 。FART的代码是通过修改少量Android源码文件而成的，经过修改的Android源码编译成系统镜像，刷入手机，这样的手机启动后，就成为一台可以用于脱壳的脱壳机。</p>
<h2 id="0x2-流程分析"><a href="#0x2-流程分析" class="headerlink" title="0x2 流程分析"></a>0x2 流程分析</h2><p>FART的入口在<code>frameworks\base\core\java\android\app\ActivityThread.java</code>的performLaunchActivity函数中，即APP的Activity启动的时候执行fartthread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">&quot;ActivityThread&quot;</span>,<span class="string">&quot;go into performLaunchActivity&quot;</span>);</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//开启fart线程</span></span><br><span class="line">    fartthread();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fartthread函数开启一个线程，休眠一分钟后调用fart函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fartthread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;start sleep,wait for fartthread start......&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;sleep over and start fartthread&quot;</span>);</span><br><span class="line">            fart();</span><br><span class="line">            Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;fart run over&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fart函数中，获取Classloader,反射获取一些类。反射调用<code>dalvik.system.DexPathList</code>的dexElements字段得到<code>dalvik.system.DexPathList$Element</code>类对象数组，Element类存储着dex的路径等信息。接下来通过遍历<code>dexElements</code>，得到每一个Element对象中的DexFile对象，再获取DexFile对象中的mCookie字段值，调用DexFile类中的<code>String[] getClassNameList(Object cookie)</code>函数并传入获取到mCookie，以得到dex文件中所有的类名。随后，遍历dex中的所有类名，传入<code>loadClassAndInvoke</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader appClassloader = getClassloader();</span><br><span class="line">    List&lt;Object&gt; dexFilesArray = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    Field pathList_Field = (Field) getClassField(appClassloader, <span class="string">&quot;dalvik.system.BaseDexClassLoader&quot;</span>, <span class="string">&quot;pathList&quot;</span>);</span><br><span class="line">    Object pathList_object = getFieldOjbect(<span class="string">&quot;dalvik.system.BaseDexClassLoader&quot;</span>, appClassloader, <span class="string">&quot;pathList&quot;</span>);</span><br><span class="line">    Object[] ElementsArray = (Object[]) getFieldOjbect(<span class="string">&quot;dalvik.system.DexPathList&quot;</span>, pathList_object, <span class="string">&quot;dexElements&quot;</span>);</span><br><span class="line">    Field dexFile_fileField = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dexFile_fileField = (Field) getClassField(appClassloader, <span class="string">&quot;dalvik.system.DexPathList$Element&quot;</span>, <span class="string">&quot;dexFile&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Class DexFileClazz = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DexFileClazz = appClassloader.loadClass(<span class="string">&quot;dalvik.system.DexFile&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Method getClassNameList_method = <span class="keyword">null</span>;</span><br><span class="line">    Method defineClass_method = <span class="keyword">null</span>;</span><br><span class="line">    Method dumpDexFile_method = <span class="keyword">null</span>;</span><br><span class="line">    Method dumpMethodCode_method = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Method field : DexFileClazz.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;getClassNameList&quot;</span>)) &#123;</span><br><span class="line">            getClassNameList_method = field;</span><br><span class="line">            getClassNameList_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;defineClassNative&quot;</span>)) &#123;</span><br><span class="line">            defineClass_method = field;</span><br><span class="line">            defineClass_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;dumpMethodCode&quot;</span>)) &#123;</span><br><span class="line">            dumpMethodCode_method = field;</span><br><span class="line">            dumpMethodCode_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Field mCookiefield = getClassField(appClassloader, <span class="string">&quot;dalvik.system.DexFile&quot;</span>, <span class="string">&quot;mCookie&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ElementsArray.length; j++) &#123;</span><br><span class="line">        Object element = ElementsArray[j];</span><br><span class="line">        Object dexfile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dexfile = (Object) dexFile_fileField.get(element);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dexfile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dexfile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dexFilesArray.add(dexfile);</span><br><span class="line">            Object mcookie = getClassFieldObject(appClassloader, <span class="string">&quot;dalvik.system.DexFile&quot;</span>, dexfile, <span class="string">&quot;mCookie&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (mcookie == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] classnames = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                classnames = (String[]) getClassNameList_method.invoke(dexfile, mcookie);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (classnames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String eachclassname : classnames) &#123;</span><br><span class="line">                    loadClassAndInvoke(appClassloader, eachclassname, dumpMethodCode_method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadClassAndInvoke除了传入上面提到的类名，还传入ClassLoader对象和dumpMethodCode函数的Method对象，看上面的代码可以知道，dumpMethodCode函数来自DexFile,原本的DexFile类没有这个函数，是FART加上去的。dumpMethodCode究竟做了什么我们待会再来看，先把loadClassAndInvoke函数看完。loadClassAndInvoke工作也很简单，根据传入的类名来加载类，再从加载的类获取它的所有的构造函数和函数，然后调用dumpMethodCode，传入Constructor对象或者Method对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadClassAndInvoke</span><span class="params">(ClassLoader appClassloader, String eachclassname, Method dumpMethodCode_method)</span> </span>&#123;</span><br><span class="line">    Log.i(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;go into loadClassAndInvoke-&gt;&quot;</span> + <span class="string">&quot;classname:&quot;</span> + eachclassname);</span><br><span class="line">    Class resultclass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resultclass = appClassloader.loadClass(eachclassname);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (resultclass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt; cons[] = resultclass.getDeclaredConstructors();</span><br><span class="line">            <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : cons) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dumpMethodCode_method != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        dumpMethodCode_method.invoke(<span class="keyword">null</span>, constructor);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;dumpMethodCode_method is null &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method[] methods = resultclass.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">if</span> (methods != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dumpMethodCode_method != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                           dumpMethodCode_method.invoke(<span class="keyword">null</span>, m);</span><br><span class="line">                         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;dumpMethodCode_method is null &quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提到dumpMethodCode函数在DexFile类中，DexFile的完整路径为：<code>libcore\dalvik\src\main\java\dalvik\system\DexFile.java</code>,它是这么定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">dumpMethodCode</span><span class="params">(Object m)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可见，它是一个native方法，它的实际代码在：<code>art\runtime\native\dalvik_system_DexFile.cc</code>，代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DexFile_dumpMethodCode</span><span class="params">(JNIEnv* env, jclass,jobject method)</span> </span>&#123;</span><br><span class="line"><span class="function">ScopedFastNativeObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="keyword">if</span>(method!=<span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">		  ArtMethod* artmethod = ArtMethod::<span class="built_in">FromReflectedMethod</span>(soa, method);</span><br><span class="line">		  <span class="built_in">myfartInvoke</span>(artmethod);</span><br><span class="line">	  &#125;	  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DexFile_dumpMethodCode函数中，method是loadClassAndInvoke函数传过来的<code>java.lang.reflect.Method</code>对象，传进来的Java层Method对象传入FromReflectedMethod函数得到ArtMethod结构指针，再将ArtMethod结构指针传入myfartInvoke函数。</p>
<p>myfartInvoke实际代码在<code>art/runtime/art_method.cc</code>文件里</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">myfartInvoke</span><span class="params">(ArtMethod * artmethod)</span></span></span><br><span class="line"><span class="function"> <span class="title">SHARED_LOCKS_REQUIRED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">	JValue *result = <span class="literal">nullptr</span>;</span><br><span class="line">	Thread *self = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> temp = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> *args = &amp;temp;</span><br><span class="line">	<span class="keyword">uint32_t</span> args_size = <span class="number">6</span>;</span><br><span class="line">	artmethod-&gt;<span class="built_in">Invoke</span>(self, args, args_size, result, <span class="string">&quot;fart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在myfartInvoke函数中，值得关注的是self被设置为空指针，并传入ArtMethod的Invoke函数。</p>
<p>Invoke函数也是在<code>art/runtime/art_method.cc</code>文件里，在Invoke函数开头，它对self参数做了个判断，如果self为空，说明Invoke函数是被FART所调用的，反之则是系统本身的调用。self为空的时候，调用dumpArtMethod函数，并立即返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::Invoke</span><span class="params">(Thread * self, <span class="keyword">uint32_t</span> * args,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">uint32_t</span> args_size, JValue * result,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">const</span> <span class="keyword">char</span> *shorty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (self == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">dumpArtMethod</span>(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ......	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dumpArtMethod函数这里就到了dump dex的代码了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">dumpArtMethod</span><span class="params">(ArtMethod * artmethod)</span></span></span><br><span class="line"><span class="function"> <span class="title">SHARED_LOCKS_REQUIRED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *dexfilepath = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">2000</span>);</span><br><span class="line">	<span class="keyword">if</span> (dexfilepath == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">LOG</span>(INFO) &lt;&lt;</span><br><span class="line">		    <span class="string">&quot;ArtMethod::dumpArtMethodinvoked,methodname:&quot;</span></span><br><span class="line">		    &lt;&lt; <span class="built_in">PrettyMethod</span>(artmethod).</span><br><span class="line">		    <span class="built_in">c_str</span>() &lt;&lt; <span class="string">&quot;malloc 2000 byte failed&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fcmdline = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> szCmdline[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> szProcName[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> procid = <span class="built_in">getpid</span>();</span><br><span class="line">	<span class="built_in">sprintf</span>(szCmdline, <span class="string">&quot;/proc/%d/cmdline&quot;</span>, procid);</span><br><span class="line">	fcmdline = <span class="built_in">open</span>(szCmdline, O_RDONLY, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span> (fcmdline &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">read</span>(fcmdline, szProcName, <span class="number">256</span>);</span><br><span class="line">		<span class="built_in">close</span>(fcmdline);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (szProcName[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> DexFile *dex_file = artmethod-&gt;<span class="built_in">GetDexFile</span>(); </span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *methodname =</span><br><span class="line">		    <span class="built_in">PrettyMethod</span>(artmethod).<span class="built_in">c_str</span>();</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">uint8_t</span> *begin_ = dex_file-&gt;<span class="built_in">Begin</span>(); </span><br><span class="line">		<span class="keyword">size_t</span> size_ = dex_file-&gt;<span class="built_in">Size</span>(); </span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">		<span class="keyword">int</span> size_int_ = (<span class="keyword">int</span>) size_;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">		<span class="built_in">sprintf</span>(dexfilepath, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;/sdcard/fart&quot;</span>);</span><br><span class="line">		<span class="built_in">mkdir</span>(dexfilepath, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">		<span class="built_in">sprintf</span>(dexfilepath, <span class="string">&quot;/sdcard/fart/%s&quot;</span>,</span><br><span class="line">			szProcName);</span><br><span class="line">		<span class="built_in">mkdir</span>(dexfilepath, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">		<span class="built_in">sprintf</span>(dexfilepath,</span><br><span class="line">			<span class="string">&quot;/sdcard/fart/%s/%d_dexfile.dex&quot;</span>,</span><br><span class="line">			szProcName, size_int_);</span><br><span class="line">		<span class="keyword">int</span> dexfilefp = <span class="built_in">open</span>(dexfilepath, O_RDONLY, <span class="number">0666</span>);</span><br><span class="line">		<span class="keyword">if</span> (dexfilefp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">close</span>(dexfilefp);</span><br><span class="line">			dexfilefp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dexfilefp =</span><br><span class="line">			    <span class="built_in">open</span>(dexfilepath, O_CREAT | O_RDWR,</span><br><span class="line">				 <span class="number">0666</span>);</span><br><span class="line">			<span class="keyword">if</span> (dexfilefp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">write</span>(dexfilefp, (<span class="keyword">void</span> *) begin_,</span><br><span class="line">				      size_); </span><br><span class="line">				<span class="built_in">fsync</span>(dexfilefp);</span><br><span class="line">				<span class="built_in">close</span>(dexfilefp);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//下半部分开始</span></span><br><span class="line">		<span class="keyword">const</span> DexFile::CodeItem * code_item =</span><br><span class="line">		    artmethod-&gt;<span class="built_in">GetCodeItem</span>(); <span class="comment">// (1)</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">LIKELY</span>(code_item != <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> code_item_len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">uint8_t</span> *item = (<span class="keyword">uint8_t</span> *) code_item;</span><br><span class="line">			<span class="keyword">if</span> (code_item-&gt;tries_size_ &gt; <span class="number">0</span>) &#123; <span class="comment">// (2)</span></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">uint8_t</span> *handler_data = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *) (DexFile::<span class="built_in">GetTryItems</span>(*code_item,code_item-&gt;tries_size_));</span><br><span class="line">				<span class="keyword">uint8_t</span> *tail = <span class="built_in">codeitem_end</span>(&amp;handler_data);</span><br><span class="line">				code_item_len = (<span class="keyword">int</span>)(tail - item);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				code_item_len =</span><br><span class="line">				    <span class="number">16</span> +</span><br><span class="line">				    code_item-&gt;</span><br><span class="line">				    insns_size_in_code_units_ * <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">			<span class="keyword">int</span> size_int = (<span class="keyword">int</span>) dex_file-&gt;<span class="built_in">Size</span>();	<span class="comment">// Length of data</span></span><br><span class="line">			<span class="keyword">uint32_t</span> method_idx =</span><br><span class="line">			    artmethod-&gt;<span class="built_in">get_method_idx</span>();</span><br><span class="line">			<span class="built_in">sprintf</span>(dexfilepath,</span><br><span class="line">				<span class="string">&quot;/sdcard/fart/%s/%d_%ld.bin&quot;</span>,</span><br><span class="line">				szProcName, size_int, <span class="built_in">gettidv1</span>());</span><br><span class="line">			<span class="keyword">int</span> fp2 =</span><br><span class="line">			    <span class="built_in">open</span>(dexfilepath,</span><br><span class="line">				 O_CREAT | O_APPEND | O_RDWR,</span><br><span class="line">				 <span class="number">0666</span>);</span><br><span class="line">			<span class="keyword">if</span> (fp2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">lseek</span>(fp2, <span class="number">0</span>, SEEK_END);</span><br><span class="line">				<span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">				<span class="keyword">int</span> offset = (<span class="keyword">int</span>) (item - begin_);</span><br><span class="line">				<span class="built_in">sprintf</span>(dexfilepath,</span><br><span class="line">					<span class="string">&quot;&#123;name:%s,method_idx:%d,offset:%d,code_item_len:%d,ins:&quot;</span>,</span><br><span class="line">					methodname, method_idx,</span><br><span class="line">					offset, code_item_len);</span><br><span class="line">				<span class="keyword">int</span> contentlength = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span> (dexfilepath[contentlength]</span><br><span class="line">				       != <span class="number">0</span>)</span><br><span class="line">					contentlength++;</span><br><span class="line">				<span class="built_in">write</span>(fp2, (<span class="keyword">void</span> *) dexfilepath,</span><br><span class="line">				      contentlength);</span><br><span class="line">				<span class="keyword">long</span> outlen = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">char</span> *base64result =</span><br><span class="line">				    <span class="built_in">base64_encode</span>((<span class="keyword">char</span> *) item,</span><br><span class="line">						  (<span class="keyword">long</span>)</span><br><span class="line">						  code_item_len,</span><br><span class="line">						  &amp;outlen);</span><br><span class="line">				<span class="built_in">write</span>(fp2, base64result, outlen);</span><br><span class="line">				<span class="built_in">write</span>(fp2, <span class="string">&quot;&#125;;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">				<span class="built_in">fsync</span>(fp2);</span><br><span class="line">				<span class="built_in">close</span>(fp2);</span><br><span class="line">				<span class="keyword">if</span> (base64result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					<span class="built_in">free</span>(base64result);</span><br><span class="line">					base64result = <span class="literal">nullptr</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dexfilepath != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dexfilepath);</span><br><span class="line">		dexfilepath = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dumpArtMethod函数开始先通过<code>/proc/&lt;pid&gt;/cmdline</code>虚拟文件读取进程pid对应的进程名，根据得到的进程名在sdcard下创建目录，所以在脱壳之前要给APP写入外部存储的权限。之后通过ArtMethod的GetDexFile函数得到DexFile指针，即ArtMethod所在的dex的指针，再从DexFile的Begin函数和Size函数得到dex文件在内存中起始的地址和dex文件的大小，接着用write函数把内存中的dex写到文件名以<code>_dexfile.dex</code>的文件中。</p>
<p>但该函数还没完，dumpArtMethod函数的下半部分，对函数的CodeItem进行dump。可能有些人就有疑问了，函数的上半部分不是把dex给dump了吗，为什么还需要取函数的CodeItem进行dump呢？对于某些壳，dumpArtMethod的上半部分已经能对dex进行整体dump,但是对于部分抽取壳，dex即使被dump下来，函数体还是以nop填充，即空函数体，FART还把函数的CodeItem给dump下来是让用户手动来修复这些dump下来的空函数。</p>
<p>我们来看dumpArtMethod函数的下半部分，这里将会涉及dex文件的结构，如果不了解请结合文档来看。注释<code>(1)</code>处，从ArtMethod中得到一个CodeItem。注释<code>(2)</code>处，根据CodeItem的<code>tries_size_</code>，即try_item的数量来计算CodeItem的大小：</p>
<p>(1)如果tries_size_不为0，说明这个CodeItem有try_item，那么去把CodeItem的结尾地址给算出来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *handler_data = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *) (DexFile::<span class="built_in">GetTryItems</span>(*code_item,code_item-&gt;tries_size_));</span><br><span class="line">				<span class="keyword">uint8_t</span> *tail = <span class="built_in">codeitem_end</span>(&amp;handler_data);</span><br><span class="line">				code_item_len = (<span class="keyword">int</span>)(tail - item);</span><br></pre></td></tr></table></figure>

<p>codeitem_end函数怎么算出CodeItem的结束地址呢？</p>
<p>GetTryItems第二参数传入<code>tries_size_</code>，即跳过所有的try_item，得到encoded_catch_handler_list的地址，然后传入codeitem_end函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">codeitem_end</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> ** pData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> num_of_list = <span class="built_in">DecodeUnsignedLeb128</span>(pData);</span><br><span class="line">    <span class="keyword">for</span> (; num_of_list &gt; <span class="number">0</span>; num_of_list--) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> num_of_handlers =</span><br><span class="line">            <span class="built_in">DecodeSignedLeb128</span>(pData);</span><br><span class="line">        <span class="keyword">int</span> num = num_of_handlers;</span><br><span class="line">        <span class="keyword">if</span> (num_of_handlers &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            num = -num_of_handlers;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; num &gt; <span class="number">0</span>; num--) &#123;</span><br><span class="line">            <span class="built_in">DecodeUnsignedLeb128</span>(pData);</span><br><span class="line">            <span class="built_in">DecodeUnsignedLeb128</span>(pData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num_of_handlers &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">DecodeUnsignedLeb128</span>(pData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint8_t</span> *) (*pData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>codeitem_end函数的开头读取encoded_catch_handler_list结构中包含多少个encoded_catch_handler结构，如果不为0，遍历所有encoded_catch_handler结构，读取encoded_catch_handler结构中有多少encoded_type_addr_pair结构，有的话全部跳过，即跳过了整个encoded_catch_handler_list结构。最后函数返回的pData即为CodeItem的结尾地址。</p>
<p>得到了CodeItem结尾地址，用CodeItem结尾的地址减去CodeItem的起始地址得到CodeItem的真实大小。</p>
<p>(2)如果tries_size_为0，那么就没有try_item，直接就能把CodeItem的大小计算出来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code_item_len = <span class="number">16</span> + code_item-&gt;insns_size_in_code_units_ * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>CodeItem的大小计算出来之后，接下来可以看到，有几个变量以格式化的方式打印到dexfilepath</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(dexfilepath,</span><br><span class="line">    <span class="string">&quot;&#123;name:%s,method_idx:%d,offset:%d,code_item_len:%d,ins:&quot;</span>,</span><br><span class="line">    methodname, </span><br><span class="line">    method_idx,</span><br><span class="line">    offset, </span><br><span class="line">    code_item_len</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>name 函数的名称</li>
<li>method_idx 来源FART新增的函数：<code>uint32_t get_method_idx()&#123; return dex_method_index_; &#125;</code>,函数返回dex_method_index_，dex_method_index_是函数在<code>method_ids</code>中的索引</li>
<li>offset 是该函数的CodeItem相对于dex文件开始的偏移</li>
<li>code_item_len CodeItem的长度</li>
</ul>
<p>数据组装好之后，写入到以<code>.bin</code>为后缀的文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(fp2, (<span class="keyword">void</span> *) dexfilepath,</span><br><span class="line">        contentlength);</span><br><span class="line"><span class="keyword">long</span> outlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *base64result =</span><br><span class="line">    <span class="built_in">base64_encode</span>((<span class="keyword">char</span> *) item,</span><br><span class="line">            (<span class="keyword">long</span>)</span><br><span class="line">            code_item_len,</span><br><span class="line">            &amp;outlen);</span><br><span class="line"><span class="built_in">write</span>(fp2, base64result, outlen);</span><br><span class="line"><span class="built_in">write</span>(fp2, <span class="string">&quot;&#125;;&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>对于上面的dexfilepath，它们是明文字符，直接写入即可。而对于CodeItem中的bytecode这种非明文字符，直接写入不太好看，所以FART选择对它们进行base64编码后再写入。</p>
<p>分析到这里好像已经结束了，从主动调用，到dex整体dump，再到函数CodeItem的dump，都已经分析了。但是FART中确实还有一部分逻辑是没有分析的。如果你使用过FART来脱过壳，会发现它dump下来的dex中还有以<code>_execute.dex</code>结尾的dex文件。这种dex是怎么生成的呢？</p>
<p>这一部分的代码也是在<code>art\runtime\art_method.cc</code>文件中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">dumpDexFileByExecute</span><span class="params">(ArtMethod * artmethod)</span></span></span><br><span class="line"><span class="function"> <span class="title">SHARED_LOCKS_REQUIRED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *dexfilepath = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">2000</span>);</span><br><span class="line">	<span class="keyword">if</span> (dexfilepath == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">LOG</span>(INFO) &lt;&lt;</span><br><span class="line">		    <span class="string">&quot;ArtMethod::dumpDexFileByExecute,methodname:&quot;</span></span><br><span class="line">		    &lt;&lt; <span class="built_in">PrettyMethod</span>(artmethod).</span><br><span class="line">		    <span class="built_in">c_str</span>() &lt;&lt; <span class="string">&quot;malloc 2000 byte failed&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fcmdline = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> szCmdline[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> szProcName[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> procid = <span class="built_in">getpid</span>();</span><br><span class="line">	<span class="built_in">sprintf</span>(szCmdline, <span class="string">&quot;/proc/%d/cmdline&quot;</span>, procid);</span><br><span class="line">	fcmdline = <span class="built_in">open</span>(szCmdline, O_RDONLY, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span> (fcmdline &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">read</span>(fcmdline, szProcName, <span class="number">256</span>);</span><br><span class="line">		<span class="built_in">close</span>(fcmdline);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (szProcName[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> DexFile *dex_file = artmethod-&gt;<span class="built_in">GetDexFile</span>();</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">uint8_t</span> *begin_ = dex_file-&gt;<span class="built_in">Begin</span>();	<span class="comment">// Start of data.</span></span><br><span class="line">		<span class="keyword">size_t</span> size_ = dex_file-&gt;<span class="built_in">Size</span>();	<span class="comment">// Length of data.</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">		<span class="keyword">int</span> size_int_ = (<span class="keyword">int</span>) size_;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">		<span class="built_in">sprintf</span>(dexfilepath, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;/sdcard/fart&quot;</span>);</span><br><span class="line">		<span class="built_in">mkdir</span>(dexfilepath, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">		<span class="built_in">sprintf</span>(dexfilepath, <span class="string">&quot;/sdcard/fart/%s&quot;</span>,</span><br><span class="line">			szProcName);</span><br><span class="line">		<span class="built_in">mkdir</span>(dexfilepath, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">		<span class="built_in">sprintf</span>(dexfilepath,</span><br><span class="line">			<span class="string">&quot;/sdcard/fart/%s/%d_dexfile_execute.dex&quot;</span>,</span><br><span class="line">			szProcName, size_int_);</span><br><span class="line">		<span class="keyword">int</span> dexfilefp = <span class="built_in">open</span>(dexfilepath, O_RDONLY, <span class="number">0666</span>);</span><br><span class="line">		<span class="keyword">if</span> (dexfilefp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">close</span>(dexfilefp);</span><br><span class="line">			dexfilefp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dexfilefp =</span><br><span class="line">			    <span class="built_in">open</span>(dexfilepath, O_CREAT | O_RDWR,</span><br><span class="line">				 <span class="number">0666</span>);</span><br><span class="line">			<span class="keyword">if</span> (dexfilefp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">write</span>(dexfilefp, (<span class="keyword">void</span> *) begin_,</span><br><span class="line">				      size_);</span><br><span class="line">				<span class="built_in">fsync</span>(dexfilefp);</span><br><span class="line">				<span class="built_in">close</span>(dexfilefp);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dexfilepath != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(dexfilepath);</span><br><span class="line">		dexfilepath = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，dumpDexFileByExecute函数有点像dumpArtMethod函数的上半部分，即对dex文件的整体dump。那么，dumpDexFileByExecute在哪里被调用呢？</p>
<p>通过搜索，在<code>art\runtime\interpreter\interpreter.cc</code>文件的开始，看到了FART在art命名空间下定义了一个dumpDexFileByExecute函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> art &#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">dumpDexFileByExecute</span><span class="params">(ArtMethod* artmethod)</span></span>;</span><br><span class="line"><span class="keyword">namespace</span> interpreter &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时在文件其中找到了对dumpDexFileByExecute函数的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> JValue <span class="title">Execute</span><span class="params">(Thread* self, <span class="keyword">const</span> DexFile::CodeItem* code_item,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ShadowFrame&amp; shadow_frame, JValue result_register)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strstr</span>(<span class="built_in">PrettyMethod</span>(shadow_frame.<span class="built_in">GetMethod</span>()).<span class="built_in">c_str</span>(),<span class="string">&quot;&lt;clinit&gt;&quot;</span>)!=<span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="built_in">dumpDexFileByExecute</span>(shadow_frame.<span class="built_in">GetMethod</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Execute函数中，通过判断函数名称中是否为<code>&lt;clinit&gt;</code>决定要不要调用dumpDexFileByExecute，即判断传入的是否为静态代码块，对于加了壳的App来说静态代码块是肯定存在的。如果Execute传入的是静态代码块则调用dumpDexFileByExecute函数，并传入一个ArtMethod指针。</p>
<p>dumpDexFileByExecute中对dex进行了整体dump，可以把它看作是dumpArtMethod方式的互补，有时dumpArtMethod中得不到想得到的dex,用dumpDexFileByExecute或许能得到惊喜。</p>
<h2 id="0x3-结语"><a href="#0x3-结语" class="headerlink" title="0x3 结语"></a>0x3 结语</h2><p>非常感谢FART作者能够开源FART，这使得人们对抗ART环境下App壳得到了良好的思路。FART脱壳机理论上来讲能脱大多数壳，但是仍有例外，需要自行摸索。</p>
<h2 id="0x4-参考"><a href="#0x4-参考" class="headerlink" title="0x4 参考"></a>0x4 参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-252630.htm">https://bbs.pediy.com/thread-252630.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/tech/dalvik/dex-format">https://source.android.google.cn/devices/tech/dalvik/dex-format</a></li>
</ul>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2021/04/03/x86%E5%B9%B3%E5%8F%B0inline-hook%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/" class="prev">上一篇</a><a href="/2021/04/03/%E4%BF%AE%E5%A4%8DFART-dump%E4%B8%8B%E6%9D%A5%E7%9A%84dex/" class="next">下一篇</a></div><div class="copyright"><p>© 2021 <a href="http://luoyesiqiu.github.io">luoyesiqiu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>