<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>luoyesiqiu</title>
  
  
  <link href="http://luoyesiqiu.github.io/atom.xml" rel="self"/>
  
  <link href="http://luoyesiqiu.github.io/"/>
  <updated>2021-04-03T05:04:19.310Z</updated>
  <id>http://luoyesiqiu.github.io/</id>
  
  <author>
    <name>luoyesiqiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>x86平台inline hook原理和实现</title>
    <link href="http://luoyesiqiu.github.io/2021/04/03/x86%E5%B9%B3%E5%8F%B0inline-hook%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://luoyesiqiu.github.io/2021/04/03/x86%E5%B9%B3%E5%8F%B0inline-hook%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-04-03T04:57:32.000Z</published>
    <updated>2021-04-03T05:04:19.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>inline hook是一种通过修改机器码的方式来实现hook的技术。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>对于正常执行的程序，它的函数调用流程大概是这样的：</p><p><img src="/images/x86-inlinehook/normal-call.png"></p><p>0x1000地址的call指令执行后跳转到0x3000地址处执行，执行完毕后再返回执行call指令的下一条指令。</p><p>我们在hook的时候，可能会读取或者修改call指令执行之前所压入栈的内容。那么，我们可以将call指令<strong>替换</strong>成jmp指令，jmp到我们自己编写的函数，在函数里call原来的函数，函数结束后再jmp回到原先call指令的下一条指令。如图：</p><p><img src="/images/x86-inlinehook/inlinehook.png"></p><p>通过修改机器码实现的inline hook，不仅不会破坏原本的程序逻辑，而且还能执行我们的代码，读写被hook的函数的数据。</p><h2 id="inline-hook流程"><a href="#inline-hook流程" class="headerlink" title="inline hook流程"></a>inline hook流程</h2><h3 id="1-寻找hook位置"><a href="#1-寻找hook位置" class="headerlink" title="(1)寻找hook位置"></a>(1)寻找hook位置</h3><p>在逆向的时候，会遇到不同类型的call，它们所占的字节可能是不一样的，本文构造一个长度为5字节的jmp指令（jmp的机器码占用1字节，跳转到的地址偏移占用4字节）来替换原来的5字节的call指令。即我们需要寻找长度为5字节的call，来进行inline hook。5字节的call形如：</p><p><img src="/images/x86-inlinehook/callasm.png"></p><h3 id="2-inline-hook代码实现"><a href="#2-inline-hook代码实现" class="headerlink" title="(2)inline hook代码实现"></a>(2)inline hook代码实现</h3><p>在x86汇编中，同样有很多类型的jmp，本文构造inline hook使用的是近距离地址跳转的jmp指令，它的机器码为<code>E9</code>，这种类型的jmp指令需要一个参数，参数是<strong>当前jmp指令地址</strong>距离<strong>目标函数地址</strong>的字节数。</p><p>假设需要hook的call的指令的内存地址为：<code>0x1000</code>，我们想要它执行后跳转到我们的函数（假设函数在内存中的地址：<code>0x5000</code>），那么，构造jmp指令时，指令应为：</p><p><code>jmp (0x5000-(0x1000 + 5))</code>  </p><p>即：</p><p><code>jmp 0x3FFB</code></p><p>对于5字节指令的hook，上面的计算公式是固定的，jmp指令本身占用5字节，所以加上5</p><p>懂了这些知识，就可以动手编写hook代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StartHook</span><span class="params">(DWORD hookAddr, BYTE backCode[<span class="number">5</span>], <span class="keyword">void</span>(*FuncBeCall)())</span> </span>&#123;</span><br><span class="line">DWORD jmpAddr = (DWORD)FuncBeCall - (hookAddr + <span class="number">5</span>);</span><br><span class="line">BYTE jmpCode[<span class="number">5</span>];</span><br><span class="line">*(jmpCode + <span class="number">0</span>) = <span class="number">0xE9</span>;</span><br><span class="line">*(DWORD *)(jmpCode + <span class="number">1</span>) = jmpAddr;</span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ReadProcessMemory</span>(hProcess, (LPVOID)hookAddr, backCode, <span class="number">5</span> , <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WriteProcessMemory</span>(hProcess, (LPVOID)hookAddr, jmpCode, <span class="number">5</span>, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的StartHook函数，hookAddr接收一个将被替换的call指令的内存地址；backCode接收一个长度为5字节的数组缓冲区，用于备份原有的call指令；FuncBeCall参数接收一个返回值为void函数地址。</p><p>StartHook函数的逻辑是：根据FuncBeCall的地址计算jmp的地址，并构造一条完整的jmp指令，存入数组。我们要hook当前的进程，所以调用OpenProcess打开当前进程。调用ReadProcessMemory读取当前进程hookAddr处的指令，写入backCode数组。调用WriteProcessMemory将构造好的jmp指令写入当前进程hookAddr处。</p><p>StartHook函数第3个参数接收一个函数地址，这个函数地址指向的函数应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">OnCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OnCall函数用<code>_declspec(naked)</code>修饰，被它修饰的函数我们常称它为裸函数，裸函数的特点是在编译生成的时候不会产生过多用于平衡堆栈的指令，这意味着在裸函数中我们要编写<strong>内联汇编</strong>控制堆栈平衡。一个比较简单写法是备份所有的寄存器，做完其他操作后再把寄存器的值还原回去，代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DWORD tEax = <span class="number">0</span>,tEcx = <span class="number">0</span>,tEdx = <span class="number">0</span>,tEbx = <span class="number">0</span>,tEsp = <span class="number">0</span>,tEbp = <span class="number">0</span>,tEsi = <span class="number">0</span>,tEdi = <span class="number">0</span>;</span><br><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">OnCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">__asm &#123;</span><br><span class="line">mov tEax, eax</span><br><span class="line">mov tEcx, ecx</span><br><span class="line">mov tEdx, edx</span><br><span class="line">mov tEbx, ebx</span><br><span class="line">mov tEsp, esp</span><br><span class="line">mov tEbp, ebp</span><br><span class="line">mov tEsi, esi</span><br><span class="line">mov tEdi, edi</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">__asm &#123;</span><br><span class="line">mov eax, tEax</span><br><span class="line">mov ecx, tEcx</span><br><span class="line">mov edx, tEdx</span><br><span class="line">mov ebx, tEbx</span><br><span class="line">mov esp, tEsp</span><br><span class="line">mov ebp, tEbp</span><br><span class="line">mov esi, tEsi</span><br><span class="line">mov edi, tEdi</span><br><span class="line">call ...</span><br><span class="line">jmp ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>裸函数编写规则可以参考msdn上的<a href="https://msdn.microsoft.com/zh-cn/windows/desktop/4d12973a">这篇文档</a>。</p></blockquote><p>当我们替换到进程的jmp代码被执行，它就会跳转到该裸函数。在裸函数里，先备份所有的寄存器，然后编写我们的hook代码，编写hook代码时可以通过esp寄存器读取或者修改原call的参数，或者通过修改eax寄存器以修改原call的返回值，再或者调用其他函数等等。执行完我们的hook代码再把寄存器的值还原回去。这样就不会导致程序逻辑出错而崩溃。</p><p>但是，上面内联汇编代码的写法看起来似乎不太简洁，有更好的写法吗，答案是有的。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">OnCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">__asm &#123;</span><br><span class="line">    pushad</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">__asm &#123;</span><br><span class="line">    popad</span><br><span class="line">    call ...</span><br><span class="line">    jmp ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看，是不是简洁多了。</p><p>上面代码中，pushad的作用是把8个通用寄存器入栈，相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">push EAX</span><br><span class="line">push ECX</span><br><span class="line">push EDX</span><br><span class="line">push EBX</span><br><span class="line">push ESP</span><br><span class="line">push EBP</span><br><span class="line">push ESI</span><br><span class="line">push EDI</span><br></pre></td></tr></table></figure><p>popad作用是把栈顶的8个元素出栈，再把它们传到相应的通用寄存器，出栈顺序与pushad指令的入栈顺序正好相反，相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pop EDI</span><br><span class="line">pop ESI</span><br><span class="line">pop EBP</span><br><span class="line">pop ESP</span><br><span class="line">pop EBX</span><br><span class="line">pop EDX</span><br><span class="line">pop ECX</span><br><span class="line">pop EAX</span><br></pre></td></tr></table></figure><p>使用pushad和popad指令，通用寄存器的数据就能方便的保存下来，也可以方便的还原回去。</p><h2 id="卸载inline-hook流程"><a href="#卸载inline-hook流程" class="headerlink" title="卸载inline hook流程"></a>卸载inline hook流程</h2><p>卸载hook的流程比较简单，也是打开当前进程，把hook时备份的call指令写回原来的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Unhook</span><span class="params">(DWORD hookAddr, BYTE backCode[<span class="number">5</span>])</span> </span>&#123;</span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WriteProcessMemory</span>(hProcess, (LPVOID)hookAddr, backCode, <span class="number">5</span>, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数hookAddr是原来hook的call的内存地址，参数backCode是原来备份下来的call指令。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是针对5字节的call进行inline hook，在寻找call的时候可能会遇到许多不同的call，比如6字节的call，或者7字节的call。对于不同的call，只要掌握了inline hook原理，就可以根据实际情况编写hook代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;inline hook是一种通过修改机器码的方式来实现hook的技术。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Android FART脱壳机流程分析</title>
    <link href="http://luoyesiqiu.github.io/2021/04/03/Android-FART%E8%84%B1%E5%A3%B3%E6%9C%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://luoyesiqiu.github.io/2021/04/03/Android-FART%E8%84%B1%E5%A3%B3%E6%9C%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2021-04-03T04:37:29.000Z</published>
    <updated>2021-04-03T04:38:36.107Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发于安全客</p><p>链接：<a href="https://www.anquanke.com/post/id/219094">https://www.anquanke.com/post/id/219094</a></p></blockquote><h2 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1 前言"></a>0x1 前言</h2><p>在Android平台上，程序员编写的Java代码最终将被编译成字节码在Android虚拟机上运行。自从Android进入大众的视野后，apktool,jadx等反编译工具也层出不穷，功能也越来越强大，由Java编译成的字节码在这些反编译工具面前变得不堪一击，这相当于一个人裸奔在茫茫人海，身体的各个部位被众人一览无余。一种事物的出现，也会有与之对立的事物出现。有反编译工具的出现，当然也会有反反编译工具的出现，这种技术一般我们加固技术。APP经过加固，就相当于给那个裸奔的人穿了衣服，“衣服”在一定程度上保护了APP，使APP没那么容易被反编译。当然，有加固技术的出现，也会有反加固技术的出现，即本文要分析的脱壳技术。</p><p>Android经过多个版本的更迭，它无论在外观还是内在都有许多改变，早期的Android使用的是dalvik虚拟机，Android4.4开始加入ART虚拟机，但不默认启用。从Android5.0开始，ART取代dalvik，成为默认虚拟机。由于dalvik和ART运行机制的不同，在它们内部脱壳原理也不太相同，本文分析的是ART下的脱壳方案：FART。它的整体思路是通过<strong>主动调用</strong>的方式来实现脱壳，项目地址：<a href="https://github.com/hanbinglengyue/FART">https://github.com/hanbinglengyue/FART</a> 。FART的代码是通过修改少量Android源码文件而成的，经过修改的Android源码编译成系统镜像，刷入手机，这样的手机启动后，就成为一台可以用于脱壳的脱壳机。</p><h2 id="0x2-流程分析"><a href="#0x2-流程分析" class="headerlink" title="0x2 流程分析"></a>0x2 流程分析</h2><p>FART的入口在<code>frameworks\base\core\java\android\app\ActivityThread.java</code>的performLaunchActivity函数中，即APP的Activity启动的时候执行fartthread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">&quot;ActivityThread&quot;</span>,<span class="string">&quot;go into performLaunchActivity&quot;</span>);</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//开启fart线程</span></span><br><span class="line">    fartthread();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fartthread函数开启一个线程，休眠一分钟后调用fart函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fartthread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;start sleep,wait for fartthread start......&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;sleep over and start fartthread&quot;</span>);</span><br><span class="line">            fart();</span><br><span class="line">            Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;fart run over&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fart函数中，获取Classloader,反射获取一些类。反射调用<code>dalvik.system.DexPathList</code>的dexElements字段得到<code>dalvik.system.DexPathList$Element</code>类对象数组，Element类存储着dex的路径等信息。接下来通过遍历<code>dexElements</code>，得到每一个Element对象中的DexFile对象，再获取DexFile对象中的mCookie字段值，调用DexFile类中的<code>String[] getClassNameList(Object cookie)</code>函数并传入获取到mCookie，以得到dex文件中所有的类名。随后，遍历dex中的所有类名，传入<code>loadClassAndInvoke</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader appClassloader = getClassloader();</span><br><span class="line">    List&lt;Object&gt; dexFilesArray = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    Field pathList_Field = (Field) getClassField(appClassloader, <span class="string">&quot;dalvik.system.BaseDexClassLoader&quot;</span>, <span class="string">&quot;pathList&quot;</span>);</span><br><span class="line">    Object pathList_object = getFieldOjbect(<span class="string">&quot;dalvik.system.BaseDexClassLoader&quot;</span>, appClassloader, <span class="string">&quot;pathList&quot;</span>);</span><br><span class="line">    Object[] ElementsArray = (Object[]) getFieldOjbect(<span class="string">&quot;dalvik.system.DexPathList&quot;</span>, pathList_object, <span class="string">&quot;dexElements&quot;</span>);</span><br><span class="line">    Field dexFile_fileField = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dexFile_fileField = (Field) getClassField(appClassloader, <span class="string">&quot;dalvik.system.DexPathList$Element&quot;</span>, <span class="string">&quot;dexFile&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Class DexFileClazz = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DexFileClazz = appClassloader.loadClass(<span class="string">&quot;dalvik.system.DexFile&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Method getClassNameList_method = <span class="keyword">null</span>;</span><br><span class="line">    Method defineClass_method = <span class="keyword">null</span>;</span><br><span class="line">    Method dumpDexFile_method = <span class="keyword">null</span>;</span><br><span class="line">    Method dumpMethodCode_method = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Method field : DexFileClazz.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;getClassNameList&quot;</span>)) &#123;</span><br><span class="line">            getClassNameList_method = field;</span><br><span class="line">            getClassNameList_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;defineClassNative&quot;</span>)) &#123;</span><br><span class="line">            defineClass_method = field;</span><br><span class="line">            defineClass_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (field.getName().equals(<span class="string">&quot;dumpMethodCode&quot;</span>)) &#123;</span><br><span class="line">            dumpMethodCode_method = field;</span><br><span class="line">            dumpMethodCode_method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Field mCookiefield = getClassField(appClassloader, <span class="string">&quot;dalvik.system.DexFile&quot;</span>, <span class="string">&quot;mCookie&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ElementsArray.length; j++) &#123;</span><br><span class="line">        Object element = ElementsArray[j];</span><br><span class="line">        Object dexfile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dexfile = (Object) dexFile_fileField.get(element);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dexfile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dexfile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dexFilesArray.add(dexfile);</span><br><span class="line">            Object mcookie = getClassFieldObject(appClassloader, <span class="string">&quot;dalvik.system.DexFile&quot;</span>, dexfile, <span class="string">&quot;mCookie&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (mcookie == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] classnames = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                classnames = (String[]) getClassNameList_method.invoke(dexfile, mcookie);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (classnames != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String eachclassname : classnames) &#123;</span><br><span class="line">                    loadClassAndInvoke(appClassloader, eachclassname, dumpMethodCode_method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadClassAndInvoke除了传入上面提到的类名，还传入ClassLoader对象和dumpMethodCode函数的Method对象，看上面的代码可以知道，dumpMethodCode函数来自DexFile,原本的DexFile类没有这个函数，是FART加上去的。dumpMethodCode究竟做了什么我们待会再来看，先把loadClassAndInvoke函数看完。loadClassAndInvoke工作也很简单，根据传入的类名来加载类，再从加载的类获取它的所有的构造函数和函数，然后调用dumpMethodCode，传入Constructor对象或者Method对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadClassAndInvoke</span><span class="params">(ClassLoader appClassloader, String eachclassname, Method dumpMethodCode_method)</span> </span>&#123;</span><br><span class="line">    Log.i(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;go into loadClassAndInvoke-&gt;&quot;</span> + <span class="string">&quot;classname:&quot;</span> + eachclassname);</span><br><span class="line">    Class resultclass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resultclass = appClassloader.loadClass(eachclassname);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (resultclass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt; cons[] = resultclass.getDeclaredConstructors();</span><br><span class="line">            <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : cons) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dumpMethodCode_method != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        dumpMethodCode_method.invoke(<span class="keyword">null</span>, constructor);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;dumpMethodCode_method is null &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method[] methods = resultclass.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">if</span> (methods != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dumpMethodCode_method != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                           dumpMethodCode_method.invoke(<span class="keyword">null</span>, m);</span><br><span class="line">                         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Log.e(<span class="string">&quot;ActivityThread&quot;</span>, <span class="string">&quot;dumpMethodCode_method is null &quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到dumpMethodCode函数在DexFile类中，DexFile的完整路径为：<code>libcore\dalvik\src\main\java\dalvik\system\DexFile.java</code>,它是这么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">dumpMethodCode</span><span class="params">(Object m)</span></span>;</span><br></pre></td></tr></table></figure><p>可见，它是一个native方法，它的实际代码在：<code>art\runtime\native\dalvik_system_DexFile.cc</code>，代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DexFile_dumpMethodCode</span><span class="params">(JNIEnv* env, jclass,jobject method)</span> </span>&#123;</span><br><span class="line"><span class="function">ScopedFastNativeObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="keyword">if</span>(method!=<span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  ArtMethod* artmethod = ArtMethod::<span class="built_in">FromReflectedMethod</span>(soa, method);</span><br><span class="line">  <span class="built_in">myfartInvoke</span>(artmethod);</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexFile_dumpMethodCode函数中，method是loadClassAndInvoke函数传过来的<code>java.lang.reflect.Method</code>对象，传进来的Java层Method对象传入FromReflectedMethod函数得到ArtMethod结构指针，再将ArtMethod结构指针传入myfartInvoke函数。</p><p>myfartInvoke实际代码在<code>art/runtime/art_method.cc</code>文件里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">myfartInvoke</span><span class="params">(ArtMethod * artmethod)</span></span></span><br><span class="line"><span class="function"> <span class="title">SHARED_LOCKS_REQUIRED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">JValue *result = <span class="literal">nullptr</span>;</span><br><span class="line">Thread *self = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> temp = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> *args = &amp;temp;</span><br><span class="line"><span class="keyword">uint32_t</span> args_size = <span class="number">6</span>;</span><br><span class="line">artmethod-&gt;<span class="built_in">Invoke</span>(self, args, args_size, result, <span class="string">&quot;fart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在myfartInvoke函数中，值得关注的是self被设置为空指针，并传入ArtMethod的Invoke函数。</p><p>Invoke函数也是在<code>art/runtime/art_method.cc</code>文件里，在Invoke函数开头，它对self参数做了个判断，如果self为空，说明Invoke函数是被FART所调用的，反之则是系统本身的调用。self为空的时候，调用dumpArtMethod函数，并立即返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::Invoke</span><span class="params">(Thread * self, <span class="keyword">uint32_t</span> * args,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">uint32_t</span> args_size, JValue * result,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">const</span> <span class="keyword">char</span> *shorty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (self == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">dumpArtMethod</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dumpArtMethod函数这里就到了dump dex的代码了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">dumpArtMethod</span><span class="params">(ArtMethod * artmethod)</span></span></span><br><span class="line"><span class="function"> <span class="title">SHARED_LOCKS_REQUIRED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *dexfilepath = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">if</span> (dexfilepath == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">LOG</span>(INFO) &lt;&lt;</span><br><span class="line">    <span class="string">&quot;ArtMethod::dumpArtMethodinvoked,methodname:&quot;</span></span><br><span class="line">    &lt;&lt; <span class="built_in">PrettyMethod</span>(artmethod).</span><br><span class="line">    <span class="built_in">c_str</span>() &lt;&lt; <span class="string">&quot;malloc 2000 byte failed&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fcmdline = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">char</span> szCmdline[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> szProcName[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> procid = <span class="built_in">getpid</span>();</span><br><span class="line"><span class="built_in">sprintf</span>(szCmdline, <span class="string">&quot;/proc/%d/cmdline&quot;</span>, procid);</span><br><span class="line">fcmdline = <span class="built_in">open</span>(szCmdline, O_RDONLY, <span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span> (fcmdline &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">read</span>(fcmdline, szProcName, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">close</span>(fcmdline);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (szProcName[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DexFile *dex_file = artmethod-&gt;<span class="built_in">GetDexFile</span>(); </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *methodname =</span><br><span class="line">    <span class="built_in">PrettyMethod</span>(artmethod).<span class="built_in">c_str</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *begin_ = dex_file-&gt;<span class="built_in">Begin</span>(); </span><br><span class="line"><span class="keyword">size_t</span> size_ = dex_file-&gt;<span class="built_in">Size</span>(); </span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">int</span> size_int_ = (<span class="keyword">int</span>) size_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(dexfilepath, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;/sdcard/fart&quot;</span>);</span><br><span class="line"><span class="built_in">mkdir</span>(dexfilepath, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(dexfilepath, <span class="string">&quot;/sdcard/fart/%s&quot;</span>,</span><br><span class="line">szProcName);</span><br><span class="line"><span class="built_in">mkdir</span>(dexfilepath, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(dexfilepath,</span><br><span class="line"><span class="string">&quot;/sdcard/fart/%s/%d_dexfile.dex&quot;</span>,</span><br><span class="line">szProcName, size_int_);</span><br><span class="line"><span class="keyword">int</span> dexfilefp = <span class="built_in">open</span>(dexfilepath, O_RDONLY, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (dexfilefp &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">close</span>(dexfilefp);</span><br><span class="line">dexfilefp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dexfilefp =</span><br><span class="line">    <span class="built_in">open</span>(dexfilepath, O_CREAT | O_RDWR,</span><br><span class="line"> <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (dexfilefp &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">write</span>(dexfilefp, (<span class="keyword">void</span> *) begin_,</span><br><span class="line">      size_); </span><br><span class="line"><span class="built_in">fsync</span>(dexfilefp);</span><br><span class="line"><span class="built_in">close</span>(dexfilefp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//下半部分开始</span></span><br><span class="line"><span class="keyword">const</span> DexFile::CodeItem * code_item =</span><br><span class="line">    artmethod-&gt;<span class="built_in">GetCodeItem</span>(); <span class="comment">// (1)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LIKELY</span>(code_item != <span class="literal">nullptr</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> code_item_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint8_t</span> *item = (<span class="keyword">uint8_t</span> *) code_item;</span><br><span class="line"><span class="keyword">if</span> (code_item-&gt;tries_size_ &gt; <span class="number">0</span>) &#123; <span class="comment">// (2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *handler_data = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *) (DexFile::<span class="built_in">GetTryItems</span>(*code_item,code_item-&gt;tries_size_));</span><br><span class="line"><span class="keyword">uint8_t</span> *tail = <span class="built_in">codeitem_end</span>(&amp;handler_data);</span><br><span class="line">code_item_len = (<span class="keyword">int</span>)(tail - item);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">code_item_len =</span><br><span class="line">    <span class="number">16</span> +</span><br><span class="line">    code_item-&gt;</span><br><span class="line">    insns_size_in_code_units_ * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">int</span> size_int = (<span class="keyword">int</span>) dex_file-&gt;<span class="built_in">Size</span>();<span class="comment">// Length of data</span></span><br><span class="line"><span class="keyword">uint32_t</span> method_idx =</span><br><span class="line">    artmethod-&gt;<span class="built_in">get_method_idx</span>();</span><br><span class="line"><span class="built_in">sprintf</span>(dexfilepath,</span><br><span class="line"><span class="string">&quot;/sdcard/fart/%s/%d_%ld.bin&quot;</span>,</span><br><span class="line">szProcName, size_int, <span class="built_in">gettidv1</span>());</span><br><span class="line"><span class="keyword">int</span> fp2 =</span><br><span class="line">    <span class="built_in">open</span>(dexfilepath,</span><br><span class="line"> O_CREAT | O_APPEND | O_RDWR,</span><br><span class="line"> <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (fp2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">lseek</span>(fp2, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">int</span> offset = (<span class="keyword">int</span>) (item - begin_);</span><br><span class="line"><span class="built_in">sprintf</span>(dexfilepath,</span><br><span class="line"><span class="string">&quot;&#123;name:%s,method_idx:%d,offset:%d,code_item_len:%d,ins:&quot;</span>,</span><br><span class="line">methodname, method_idx,</span><br><span class="line">offset, code_item_len);</span><br><span class="line"><span class="keyword">int</span> contentlength = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (dexfilepath[contentlength]</span><br><span class="line">       != <span class="number">0</span>)</span><br><span class="line">contentlength++;</span><br><span class="line"><span class="built_in">write</span>(fp2, (<span class="keyword">void</span> *) dexfilepath,</span><br><span class="line">      contentlength);</span><br><span class="line"><span class="keyword">long</span> outlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *base64result =</span><br><span class="line">    <span class="built_in">base64_encode</span>((<span class="keyword">char</span> *) item,</span><br><span class="line">  (<span class="keyword">long</span>)</span><br><span class="line">  code_item_len,</span><br><span class="line">  &amp;outlen);</span><br><span class="line"><span class="built_in">write</span>(fp2, base64result, outlen);</span><br><span class="line"><span class="built_in">write</span>(fp2, <span class="string">&quot;&#125;;&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">fsync</span>(fp2);</span><br><span class="line"><span class="built_in">close</span>(fp2);</span><br><span class="line"><span class="keyword">if</span> (base64result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(base64result);</span><br><span class="line">base64result = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dexfilepath != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(dexfilepath);</span><br><span class="line">dexfilepath = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dumpArtMethod函数开始先通过<code>/proc/&lt;pid&gt;/cmdline</code>虚拟文件读取进程pid对应的进程名，根据得到的进程名在sdcard下创建目录，所以在脱壳之前要给APP写入外部存储的权限。之后通过ArtMethod的GetDexFile函数得到DexFile指针，即ArtMethod所在的dex的指针，再从DexFile的Begin函数和Size函数得到dex文件在内存中起始的地址和dex文件的大小，接着用write函数把内存中的dex写到文件名以<code>_dexfile.dex</code>的文件中。</p><p>但该函数还没完，dumpArtMethod函数的下半部分，对函数的CodeItem进行dump。可能有些人就有疑问了，函数的上半部分不是把dex给dump了吗，为什么还需要取函数的CodeItem进行dump呢？对于某些壳，dumpArtMethod的上半部分已经能对dex进行整体dump,但是对于部分抽取壳，dex即使被dump下来，函数体还是以nop填充，即空函数体，FART还把函数的CodeItem给dump下来是让用户手动来修复这些dump下来的空函数。</p><p>我们来看dumpArtMethod函数的下半部分，这里将会涉及dex文件的结构，如果不了解请结合文档来看。注释<code>(1)</code>处，从ArtMethod中得到一个CodeItem。注释<code>(2)</code>处，根据CodeItem的<code>tries_size_</code>，即try_item的数量来计算CodeItem的大小：</p><p>(1)如果tries_size_不为0，说明这个CodeItem有try_item，那么去把CodeItem的结尾地址给算出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *handler_data = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *) (DexFile::<span class="built_in">GetTryItems</span>(*code_item,code_item-&gt;tries_size_));</span><br><span class="line"><span class="keyword">uint8_t</span> *tail = <span class="built_in">codeitem_end</span>(&amp;handler_data);</span><br><span class="line">code_item_len = (<span class="keyword">int</span>)(tail - item);</span><br></pre></td></tr></table></figure><p>codeitem_end函数怎么算出CodeItem的结束地址呢？</p><p>GetTryItems第二参数传入<code>tries_size_</code>，即跳过所有的try_item，得到encoded_catch_handler_list的地址，然后传入codeitem_end函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">codeitem_end</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> ** pData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> num_of_list = <span class="built_in">DecodeUnsignedLeb128</span>(pData);</span><br><span class="line">    <span class="keyword">for</span> (; num_of_list &gt; <span class="number">0</span>; num_of_list--) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> num_of_handlers =</span><br><span class="line">            <span class="built_in">DecodeSignedLeb128</span>(pData);</span><br><span class="line">        <span class="keyword">int</span> num = num_of_handlers;</span><br><span class="line">        <span class="keyword">if</span> (num_of_handlers &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            num = -num_of_handlers;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; num &gt; <span class="number">0</span>; num--) &#123;</span><br><span class="line">            <span class="built_in">DecodeUnsignedLeb128</span>(pData);</span><br><span class="line">            <span class="built_in">DecodeUnsignedLeb128</span>(pData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num_of_handlers &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">DecodeUnsignedLeb128</span>(pData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint8_t</span> *) (*pData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>codeitem_end函数的开头读取encoded_catch_handler_list结构中包含多少个encoded_catch_handler结构，如果不为0，遍历所有encoded_catch_handler结构，读取encoded_catch_handler结构中有多少encoded_type_addr_pair结构，有的话全部跳过，即跳过了整个encoded_catch_handler_list结构。最后函数返回的pData即为CodeItem的结尾地址。</p><p>得到了CodeItem结尾地址，用CodeItem结尾的地址减去CodeItem的起始地址得到CodeItem的真实大小。</p><p>(2)如果tries_size_为0，那么就没有try_item，直接就能把CodeItem的大小计算出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code_item_len = <span class="number">16</span> + code_item-&gt;insns_size_in_code_units_ * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>CodeItem的大小计算出来之后，接下来可以看到，有几个变量以格式化的方式打印到dexfilepath</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(dexfilepath,</span><br><span class="line">    <span class="string">&quot;&#123;name:%s,method_idx:%d,offset:%d,code_item_len:%d,ins:&quot;</span>,</span><br><span class="line">    methodname, </span><br><span class="line">    method_idx,</span><br><span class="line">    offset, </span><br><span class="line">    code_item_len</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>name 函数的名称</li><li>method_idx 来源FART新增的函数：<code>uint32_t get_method_idx()&#123; return dex_method_index_; &#125;</code>,函数返回dex_method_index_，dex_method_index_是函数在<code>method_ids</code>中的索引</li><li>offset 是该函数的CodeItem相对于dex文件开始的偏移</li><li>code_item_len CodeItem的长度</li></ul><p>数据组装好之后，写入到以<code>.bin</code>为后缀的文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(fp2, (<span class="keyword">void</span> *) dexfilepath,</span><br><span class="line">        contentlength);</span><br><span class="line"><span class="keyword">long</span> outlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *base64result =</span><br><span class="line">    <span class="built_in">base64_encode</span>((<span class="keyword">char</span> *) item,</span><br><span class="line">            (<span class="keyword">long</span>)</span><br><span class="line">            code_item_len,</span><br><span class="line">            &amp;outlen);</span><br><span class="line"><span class="built_in">write</span>(fp2, base64result, outlen);</span><br><span class="line"><span class="built_in">write</span>(fp2, <span class="string">&quot;&#125;;&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>对于上面的dexfilepath，它们是明文字符，直接写入即可。而对于CodeItem中的bytecode这种非明文字符，直接写入不太好看，所以FART选择对它们进行base64编码后再写入。</p><p>分析到这里好像已经结束了，从主动调用，到dex整体dump，再到函数CodeItem的dump，都已经分析了。但是FART中确实还有一部分逻辑是没有分析的。如果你使用过FART来脱过壳，会发现它dump下来的dex中还有以<code>_execute.dex</code>结尾的dex文件。这种dex是怎么生成的呢？</p><p>这一部分的代码也是在<code>art\runtime\art_method.cc</code>文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">dumpDexFileByExecute</span><span class="params">(ArtMethod * artmethod)</span></span></span><br><span class="line"><span class="function"> <span class="title">SHARED_LOCKS_REQUIRED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *dexfilepath = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">if</span> (dexfilepath == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">LOG</span>(INFO) &lt;&lt;</span><br><span class="line">    <span class="string">&quot;ArtMethod::dumpDexFileByExecute,methodname:&quot;</span></span><br><span class="line">    &lt;&lt; <span class="built_in">PrettyMethod</span>(artmethod).</span><br><span class="line">    <span class="built_in">c_str</span>() &lt;&lt; <span class="string">&quot;malloc 2000 byte failed&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fcmdline = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">char</span> szCmdline[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> szProcName[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> procid = <span class="built_in">getpid</span>();</span><br><span class="line"><span class="built_in">sprintf</span>(szCmdline, <span class="string">&quot;/proc/%d/cmdline&quot;</span>, procid);</span><br><span class="line">fcmdline = <span class="built_in">open</span>(szCmdline, O_RDONLY, <span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span> (fcmdline &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">read</span>(fcmdline, szProcName, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">close</span>(fcmdline);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (szProcName[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DexFile *dex_file = artmethod-&gt;<span class="built_in">GetDexFile</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *begin_ = dex_file-&gt;<span class="built_in">Begin</span>();<span class="comment">// Start of data.</span></span><br><span class="line"><span class="keyword">size_t</span> size_ = dex_file-&gt;<span class="built_in">Size</span>();<span class="comment">// Length of data.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">int</span> size_int_ = (<span class="keyword">int</span>) size_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(dexfilepath, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;/sdcard/fart&quot;</span>);</span><br><span class="line"><span class="built_in">mkdir</span>(dexfilepath, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(dexfilepath, <span class="string">&quot;/sdcard/fart/%s&quot;</span>,</span><br><span class="line">szProcName);</span><br><span class="line"><span class="built_in">mkdir</span>(dexfilepath, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dexfilepath, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(dexfilepath,</span><br><span class="line"><span class="string">&quot;/sdcard/fart/%s/%d_dexfile_execute.dex&quot;</span>,</span><br><span class="line">szProcName, size_int_);</span><br><span class="line"><span class="keyword">int</span> dexfilefp = <span class="built_in">open</span>(dexfilepath, O_RDONLY, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (dexfilefp &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">close</span>(dexfilefp);</span><br><span class="line">dexfilefp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dexfilefp =</span><br><span class="line">    <span class="built_in">open</span>(dexfilepath, O_CREAT | O_RDWR,</span><br><span class="line"> <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (dexfilefp &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">write</span>(dexfilefp, (<span class="keyword">void</span> *) begin_,</span><br><span class="line">      size_);</span><br><span class="line"><span class="built_in">fsync</span>(dexfilefp);</span><br><span class="line"><span class="built_in">close</span>(dexfilefp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dexfilepath != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(dexfilepath);</span><br><span class="line">dexfilepath = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，dumpDexFileByExecute函数有点像dumpArtMethod函数的上半部分，即对dex文件的整体dump。那么，dumpDexFileByExecute在哪里被调用呢？</p><p>通过搜索，在<code>art\runtime\interpreter\interpreter.cc</code>文件的开始，看到了FART在art命名空间下定义了一个dumpDexFileByExecute函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> art &#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">dumpDexFileByExecute</span><span class="params">(ArtMethod* artmethod)</span></span>;</span><br><span class="line"><span class="keyword">namespace</span> interpreter &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在文件其中找到了对dumpDexFileByExecute函数的调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> JValue <span class="title">Execute</span><span class="params">(Thread* self, <span class="keyword">const</span> DexFile::CodeItem* code_item,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ShadowFrame&amp; shadow_frame, JValue result_register)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strstr</span>(<span class="built_in">PrettyMethod</span>(shadow_frame.<span class="built_in">GetMethod</span>()).<span class="built_in">c_str</span>(),<span class="string">&quot;&lt;clinit&gt;&quot;</span>)!=<span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">dumpDexFileByExecute</span>(shadow_frame.<span class="built_in">GetMethod</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Execute函数中，通过判断函数名称中是否为<code>&lt;clinit&gt;</code>决定要不要调用dumpDexFileByExecute，即判断传入的是否为静态代码块，对于加了壳的App来说静态代码块是肯定存在的。如果Execute传入的是静态代码块则调用dumpDexFileByExecute函数，并传入一个ArtMethod指针。</p><p>dumpDexFileByExecute中对dex进行了整体dump，可以把它看作是dumpArtMethod方式的互补，有时dumpArtMethod中得不到想得到的dex,用dumpDexFileByExecute或许能得到惊喜。</p><h2 id="0x3-结语"><a href="#0x3-结语" class="headerlink" title="0x3 结语"></a>0x3 结语</h2><p>非常感谢FART作者能够开源FART，这使得人们对抗ART环境下App壳得到了良好的思路。FART脱壳机理论上来讲能脱大多数壳，但是仍有例外，需要自行摸索。</p><h2 id="0x4-参考"><a href="#0x4-参考" class="headerlink" title="0x4 参考"></a>0x4 参考</h2><ul><li><a href="https://bbs.pediy.com/thread-252630.htm">https://bbs.pediy.com/thread-252630.htm</a></li><li><a href="https://source.android.google.cn/devices/tech/dalvik/dex-format">https://source.android.google.cn/devices/tech/dalvik/dex-format</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文首发于安全客&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.anquanke.com/post/id/219094&quot;&gt;https://www.anquanke.com/post/id/219094&lt;/a&gt;&lt;/p&gt;
&lt;/block</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>修复FART dump下来的dex</title>
    <link href="http://luoyesiqiu.github.io/2021/04/03/%E4%BF%AE%E5%A4%8DFART-dump%E4%B8%8B%E6%9D%A5%E7%9A%84dex/"/>
    <id>http://luoyesiqiu.github.io/2021/04/03/%E4%BF%AE%E5%A4%8DFART-dump%E4%B8%8B%E6%9D%A5%E7%9A%84dex/</id>
    <published>2021-04-03T03:41:07.000Z</published>
    <updated>2021-04-03T04:10:04.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-情景"><a href="#1-情景" class="headerlink" title="1. 情景"></a>1. 情景</h2><p>在使用脱壳机对Android App脱壳的时候，我们常常会得到有nop指令填充的函数的dex，nop是No Operation的缩写，意为无操作。</p><p><img src="/images/dex-repair/smali.jpg"></p><p>上面是一个函数的smali代码，可以清晰的看到函数被多个nop指令填充，如果这个函数解析成Java代码，则得到一个空的函数：</p><p><img src="/images/dex-repair/nop.jpg"></p><p>某些壳在加固的时候会把dex文件中的函数的真正函数体给抽掉，用nop指令来填充，nop指令在这个过程中只用作占位，当函数执行的时候再把真正的代码给还原回去，加固壳用这种方式来保护函数中真正的代码。我们修复的过程就是把函数的真正代码写回dex文件的过程。函数修复后：</p><p><img src="/images/dex-repair/repaired.jpg"></p><h2 id="2-修复"><a href="#2-修复" class="headerlink" title="2. 修复"></a>2. 修复</h2><p>FART在dump dex的同时，还把dex的CodeItem给dump了下来，这给我们修复dex提供了极大的便利，CodeItem中存着函数中真正代码，CodeItem dump下来后存在<code>.bin</code>文件中。所以我们修复的时候，读取<code>.bin</code>文件，把CodeItem填入Dex文件的相应的位置即可。</p><p>我们打开<code>.bin</code>文件，可以看到它由多项形如以下格式的文本组成，每一项代表一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;name:void junit.textui.ResultPrinter.printFailures(junit.framework.TestResult),method_idx:1565,offset:52440,code_item_len:46,ins:BQACAAQAAADpYAIADwAAAG4QpwUEAAwAbhCmBQQACgEbAhYFAABuQBsGAyEOAA&#x3D;&#x3D;&#125;;</span><br></pre></td></tr></table></figure><p>我们来看这些数据都是什么：</p><ul><li><code>name</code> 指示函数的全名，包括完整的参数类型和返回值类型</li><li><code>method_idx</code> 是函数在method_ids中的索引</li><li><code>offset</code> 指示函数的insns相对于dex文件的偏移</li><li><code>code_item_len</code> CodeItem的长度</li><li><code>ins</code> base64字符串，解码后是dex结构中的insns，即函数的真正的代码</li></ul><p>在dex修复过程中，对我们有用的是offset和ins，可以编写代码将它们从<code>.bin</code>文件中提取出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;CodeItem&gt; <span class="title">convertToCodeItems</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">    String input = <span class="keyword">new</span> String(bytes);</span><br><span class="line"></span><br><span class="line">    List&lt;CodeItem&gt; codeItems = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Pattern pattern = Pattern.compile(<span class="string">&quot;\\&#123;name:(.+?),method_idx:(\\d+),offset:(\\d+),code_item_len:(\\d+),ins:(.+?)\\&#125;&quot;</span>);</span><br><span class="line">    Matcher matcher = pattern.matcher(input);</span><br><span class="line">    <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = Integer.parseInt(matcher.group(<span class="number">3</span>));</span><br><span class="line">        String insBase64 = matcher.group(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] ins = Base64.getDecoder().decode(insBase64);</span><br><span class="line">        CodeItem codeItem = <span class="keyword">new</span> CodeItem(offset,ins);</span><br><span class="line">        codeItems.add(codeItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> codeItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CodeItem类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">CodeItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeItem</span><span class="params">(<span class="keyword">long</span> offset, <span class="keyword">byte</span>[] byteCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">        <span class="keyword">this</span>.byteCode = byteCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOffset</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getByteCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> byteCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setByteCode</span><span class="params">(<span class="keyword">byte</span>[] byteCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.byteCode = byteCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CodeItem&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;offset=&quot;</span> + offset +</span><br><span class="line">                <span class="string">&quot;, byteCode=&quot;</span> + Arrays.toString(byteCode) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] byteCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着将需要的修复dex复制一份，把insns填充到被复制出来的dex的相应位置，即修复过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">(String dexFile, List&lt;CodeItem&gt; codeItems)</span></span>&#123;</span><br><span class="line">    RandomAccessFile randomAccessFile = <span class="keyword">null</span>;</span><br><span class="line">    String outFile = dexFile.endsWith(<span class="string">&quot;.dex&quot;</span>) ? dexFile.replaceAll(<span class="string">&quot;\\.dex&quot;</span>,<span class="string">&quot;_repair.dex&quot;</span>) : dexFile + <span class="string">&quot;_repair.dex&quot;</span>;</span><br><span class="line">    <span class="comment">//copy dex</span></span><br><span class="line">    <span class="keyword">byte</span>[] dexData = IoUtils.readFile(dexFile);</span><br><span class="line">    IoUtils.writeFile(outFile,dexData);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        randomAccessFile = <span class="keyword">new</span> RandomAccessFile(outFile,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; codeItems.size();i++)&#123;</span><br><span class="line">            CodeItem codeItem = codeItems.get(i);</span><br><span class="line">            randomAccessFile.seek(codeItem.getOffset());</span><br><span class="line">            randomAccessFile.write(codeItem.getByteCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.close(randomAccessFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很简单，本文完。</p><h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3. 完整代码"></a>3. 完整代码</h2><p><a href="https://github.com/luoyesiqiu/DexRepair">https://github.com/luoyesiqiu/DexRepair</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-情景&quot;&gt;&lt;a href=&quot;#1-情景&quot; class=&quot;headerlink&quot; title=&quot;1. 情景&quot;&gt;&lt;/a&gt;1. 情景&lt;/h2&gt;&lt;p&gt;在使用脱壳机对Android App脱壳的时候，我们常常会得到有nop指令填充的函数的dex，nop是No Operat</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>修改Android源码实现原生应用双开，应用多开</title>
    <link href="http://luoyesiqiu.github.io/2021/03/22/%E4%BF%AE%E6%94%B9Android%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%8F%8C%E5%BC%80%EF%BC%8C%E5%BA%94%E7%94%A8%E5%A4%9A%E5%BC%80/"/>
    <id>http://luoyesiqiu.github.io/2021/03/22/%E4%BF%AE%E6%94%B9Android%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%8F%8C%E5%BC%80%EF%BC%8C%E5%BA%94%E7%94%A8%E5%A4%9A%E5%BC%80/</id>
    <published>2021-03-21T16:09:29.000Z</published>
    <updated>2021-03-21T16:13:45.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h1><p><img src="/images/multi-app/sample.png" alt="效果图"></p><p>把某系统双开的两个app的信息进行对比</p><h2 id="1-1-目录的对比"><a href="#1-1-目录的对比" class="headerlink" title="1.1 目录的对比"></a>1.1 目录的对比</h2><h3 id="1-1-1-data目录对比"><a href="#1-1-1-data目录对比" class="headerlink" title="1.1.1 data目录对比"></a>1.1.1 data目录对比</h3><p>原应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;data&#x2F;user&#x2F;0&#x2F;com.luoyesiqiu.crackme&#x2F;files</span><br></pre></td></tr></table></figure><p>被复制的应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;data&#x2F;user&#x2F;999&#x2F;com.luoyesiqiu.crackme&#x2F;files</span><br></pre></td></tr></table></figure><h3 id="1-1-2-apk所在目录对比"><a href="#1-1-2-apk所在目录对比" class="headerlink" title="1.1.2 apk所在目录对比"></a>1.1.2 apk所在目录对比</h3><p>原应用：</p><p><code>/data/app/com.luoyesiqiu.crackme-H1Dvbka0t42rzlCAqSpgHQ==/base.apk</code></p><p>被复制的应用：</p><p><code>/data/app/com.luoyesiqiu.crackme-H1Dvbka0t42rzlCAqSpgHQ==/base.apk</code></p><p>通过对比apk安装目录和数据目录，我们可以知道，该系统的双开是<strong>共用同一个apk</strong>，但是却拥有<strong>独立的数据目录</strong>。</p><h2 id="1-2-进程信息对比"><a href="#1-2-进程信息对比" class="headerlink" title="1.2 进程信息对比"></a>1.2 进程信息对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">USER           PID  PPID     VSZ    RSS WCHAN            ADDR S NAME</span><br><span class="line">u0_a161      30284   918 2276572  48420 SyS_epoll_wait      0 S com.luoyesiqiu.crackme</span><br><span class="line">u999_a161    30311   918 2276572  48004 SyS_epoll_wait      0 S com.luoyesiqiu.crackme</span><br></pre></td></tr></table></figure><p>通过查看进程信息，可以知道，这两个应用运行于<strong>不同的用户</strong>中。</p><p>为了实现和它相似的功能，我们做下文的配置。</p><h1 id="2-修改创建用户限制"><a href="#2-修改创建用户限制" class="headerlink" title="2. 修改创建用户限制"></a>2. 修改创建用户限制</h1><p>从Android5.0开始，Android支持创建Profile.默认情况下，系统只允许创建一个新的多开用户，也就是只能双开，但是修改源码可以达到创建多个用户。</p><p>修改<code>frameworks/base/services/core/java/com/android/server/pm/UserManagerService.java</code><br>的MAX_MANAGED_PROFILES字段，改成自己想要创建的最大用户数，它的默认值是1.</p><h1 id="3-创建用户"><a href="#3-创建用户" class="headerlink" title="3. 创建用户"></a>3. 创建用户</h1><p>创建一个用户即创建一个多开容器，调用createProfile方法，flag传入0x00000020，以创建一个用户并将它开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getUserIdFromUserInfo</span><span class="params">(Object userInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> userId = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field_id = userInfo.getClass().getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        field_id.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        userId = (Integer)field_id.get(userInfo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startUser</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">    Object iActivityManager = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        iActivityManager = Class.forName(<span class="string">&quot;android.app.ActivityManagerNative&quot;</span>).getMethod(<span class="string">&quot;getDefault&quot;</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isOk=(<span class="keyword">boolean</span>)iActivityManager.getClass().getMethod(<span class="string">&quot;startUserInBackground&quot;</span>,<span class="keyword">int</span>.class)</span><br><span class="line">                .invoke(iActivityManager,userId);</span><br><span class="line">        <span class="keyword">return</span> isOk;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">createProfile</span><span class="params">(Context context, String userName, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    UserManager mUserManager = (UserManager) context.getSystemService(Context.USER_SERVICE);</span><br><span class="line"></span><br><span class="line">    UserHandle userHandle = UserHandle.getUserHandleForUid(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Log.d(TAG,<span class="string">&quot;userHandle = &quot;</span>+userHandle.toString());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> getIdentifier=(<span class="keyword">int</span>)userHandle.getClass().getMethod(<span class="string">&quot;getIdentifier&quot;</span>).invoke(userHandle);</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;Identifier = &quot;</span>+getIdentifier);</span><br><span class="line">        mUserInfo=mUserManager.getClass().getMethod(<span class="string">&quot;createProfileForUser&quot;</span>,String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class)</span><br><span class="line">                .invoke(mUserManager</span><br><span class="line">                        ,userName</span><br><span class="line">                        , flag</span><br><span class="line">                        ,getIdentifier);</span><br><span class="line">        <span class="keyword">if</span>(mUserInfo==<span class="keyword">null</span>)&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;mUserInfo is null!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> userId = getUserIdFromUserInfo(mUserInfo);</span><br><span class="line">        <span class="keyword">boolean</span> isOk=startUser(userId);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;startUserInBackground() userId = &quot;</span> + userId + <span class="string">&quot; | isOk = &quot;</span> + isOk);</span><br><span class="line">        <span class="keyword">return</span> isOk ? <span class="string">&quot;&quot;</span>+userId : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：创建用户的App要在AndroidManifest.xml的manifest节点下加入<code>android:sharedUserId=&quot;android.uid.system&quot;</code>字段，加入<code>&lt;uses-permission android:name=&quot;android.permission.MANAGE_USERS&quot;/&gt;</code>权限，还要使用系统的platform签名对apk进行签名。</p></blockquote><p>上面的方法似乎有点麻烦，其实创建多开用户还有更简单的办法，只需要一条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm create-user --profileOf 0 --managed myspace</span><br></pre></td></tr></table></figure><ul><li>profileOf 指定父用户id,0即系统用户</li><li>managed 指定创建的用户为多开用户</li><li>myspace 为用户名</li></ul><h1 id="4-配置系统应用不安装到子用户"><a href="#4-配置系统应用不安装到子用户" class="headerlink" title="4. 配置系统应用不安装到子用户"></a>4. 配置系统应用不安装到子用户</h1><p>默认情况下，在创建一个新用户的时候，系统会给新用户复制一份系统应用，但是在子用户中我们并不需要系统应用，所以我们要在子用户中取消安装这些系统应用。</p><blockquote><p>注：系统应用可以不安装到子用户，但是系统服务一定要安装到子用户，否则，运行在子用户的app可能无法正常运行。</p></blockquote><p>修改frameworks/base/services/core/java/com/android/server/pm/Settings.java</p><p>createNewUserLI方法，对系统应用和系统服务是否安装到子用户进行配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] excludeLiStrings=&#123;</span><br><span class="line">    <span class="string">&quot;android&quot;</span>,</span><br><span class="line">    <span class="string">&quot;android.ext.services&quot;</span>,</span><br><span class="line">    <span class="string">&quot;android.ext.shared&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.bluetooth&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.htmlviewer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.inputdevices&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.shell&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.certinstaller&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.externalstorage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.providers.contacts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.providers.downloads&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.providers.media&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.providers.settings&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.providers.userdictionary&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.server.telecom&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.packageinstaller&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.settings&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.providers.telephony&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.mms.service&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.webview&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.location.fused&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.cts.priv.ctsshim&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.statementservice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.defcontainer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.keychain&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.proxyhandler&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.dreams.basic&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.printspooler&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.pacprocessor&quot;</span>,</span><br><span class="line">    <span class="string">&quot;com.android.providers.downloads.ui&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInExcludeList</span><span class="params">(String pkg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(String excludePkg:excludeLiStrings)&#123;</span><br><span class="line">        <span class="keyword">if</span>(excludePkg.equals(pkg))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createNewUserLI</span><span class="params">(<span class="meta">@NonNull</span> PackageManagerService service, <span class="meta">@NonNull</span> Installer installer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> userHandle)</span> </span>&#123;</span><br><span class="line">    String[] volumeUuids;</span><br><span class="line">    String[] names;</span><br><span class="line">    <span class="keyword">int</span>[] appIds;</span><br><span class="line">    String[] seinfos;</span><br><span class="line">    <span class="keyword">int</span>[] targetSdkVersions;</span><br><span class="line">    <span class="keyword">int</span> packagesCount;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        Collection&lt;PackageSetting&gt; packages = mPackages.values();</span><br><span class="line">        packagesCount = packages.size();</span><br><span class="line">        volumeUuids = <span class="keyword">new</span> String[packagesCount];</span><br><span class="line">        names = <span class="keyword">new</span> String[packagesCount];</span><br><span class="line">        appIds = <span class="keyword">new</span> <span class="keyword">int</span>[packagesCount];</span><br><span class="line">        seinfos = <span class="keyword">new</span> String[packagesCount];</span><br><span class="line">        targetSdkVersions = <span class="keyword">new</span> <span class="keyword">int</span>[packagesCount];</span><br><span class="line">        Iterator&lt;PackageSetting&gt; packagesIterator = packages.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; packagesCount; i++) &#123;</span><br><span class="line">            PackageSetting ps = packagesIterator.next();</span><br><span class="line">            <span class="keyword">if</span> (ps.pkg == <span class="keyword">null</span> || ps.pkg.applicationInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Only system apps are initially installed.</span></span><br><span class="line">            <span class="comment">//Slog.w(TAG, &quot;User handle:&quot;+userHandle+&quot;,pkg name:&quot;+ps.name);</span></span><br><span class="line">            <span class="comment">//修改的地方，在列表外的应用不安装到子用户</span></span><br><span class="line">            <span class="keyword">if</span>(userHandle &gt; <span class="number">0</span> &amp;&amp; !isInExcludeList(ps.name))&#123;</span><br><span class="line">                ps.setInstalled(<span class="keyword">false</span>, userHandle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                 ps.setInstalled(ps.isSystem(), userHandle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Need to create a data directory for all apps under this user. Accumulate all</span></span><br><span class="line">            <span class="comment">// required args and call the installer after mPackages lock has been released</span></span><br><span class="line">            volumeUuids[i] = ps.volumeUuid;</span><br><span class="line">            names[i] = ps.name;</span><br><span class="line">            appIds[i] = ps.appId;</span><br><span class="line">            seinfos[i] = ps.pkg.applicationInfo.seinfo;</span><br><span class="line">            targetSdkVersions[i] = ps.pkg.applicationInfo.targetSdkVersion;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; packagesCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (names[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> triage flags!</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = StorageManager.FLAG_STORAGE_CE | StorageManager.FLAG_STORAGE_DE;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            installer.createAppData(volumeUuids[i], names[i], userHandle, flags, appIds[i],</span><br><span class="line">                    seinfos[i], targetSdkVersions[i]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstallerException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Failed to prepare app data&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        applyDefaultPreferredAppsLPw(service, userHandle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-给非系统用户安装和卸载软件"><a href="#5-给非系统用户安装和卸载软件" class="headerlink" title="5. 给非系统用户安装和卸载软件"></a>5. 给非系统用户安装和卸载软件</h1><ol><li>安装app到指定用户</li></ol><p><code>pm install -t -r --user &lt;userId&gt; &lt;apkPath&gt;</code></p><ul><li><p>-r 替换存在的</p></li><li><p>–user 指定安装到的用户</p></li></ul><blockquote><p>注：安装app后要重启默认启动器（Launcher），不然可能会出现奇怪的问题</p></blockquote><ol start="2"><li>从指定用户卸载app</li></ol><p><code>pm uninstall --user &lt;userId&gt; &lt;pkgName&gt;</code></p><h1 id="6-设置App默认只安装到主用户"><a href="#6-设置App默认只安装到主用户" class="headerlink" title="6. 设置App默认只安装到主用户"></a>6. 设置App默认只安装到主用户</h1><p>开启子用户后，如果调用<code>adb install</code>或者<code>pm install</code>来安装apk,会把apk安装所有用户。这不是我们想要的，所以，我们修改成执行这些命令时，只把app安装到主用户。</p><p>第一步：针对用pm install命令安装apk的方式</p><p>frameworks/base/cmds/pm/src/com/android/commands/pm/Pm.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstallParams</span> </span>&#123;</span><br><span class="line">    SessionParams sessionParams;</span><br><span class="line">    String installerPackageName;</span><br><span class="line">    <span class="comment">//int userId = UserHandle.USER_ALL;</span></span><br><span class="line">    <span class="keyword">int</span> userId = UserHandle.USER_SYSTEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：针对用adb install命令安装apk的方式</p><p>在旧版本系统上，<code>adb install</code>会调用<code>pm install</code>来安装apk,但在新版的系统上会调用<code>cmd package</code>命令来安装apk。</p><p><code>package</code>命令的具体实现在：</p><p>frameworks/base/services/core/java/com/android/server/pm/PackageManagerShellCommand.java</p><p>所以，修改以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstallParams</span> </span>&#123;</span><br><span class="line">    SessionParams sessionParams;</span><br><span class="line">    String installerPackageName;</span><br><span class="line">    <span class="comment">//int userId = UserHandle.USER_ALL;</span></span><br><span class="line">    <span class="keyword">int</span> userId = UserHandle.USER_SYSTEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-删除用户"><a href="#7-删除用户" class="headerlink" title="7. 删除用户"></a>7. 删除用户</h1><p><code>adb shell pm remove-user &lt;userId&gt;</code></p><p>或者调用以下代码删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(Context context,<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">    UserManager userManager=(UserManager) context.getSystemService(Context.USER_SERVICE);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userManager.getClass().getMethod(<span class="string">&quot;removeUser&quot;</span>,<span class="keyword">int</span>.class).invoke(userManager,userId);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-修改用户App右下角标"><a href="#8-修改用户App右下角标" class="headerlink" title="8. 修改用户App右下角标"></a>8. 修改用户App右下角标</h1><p>开启多用户后，如果给多个子用户安装相同的App，它们会显示相同的右下小图标(在源码中被叫做Badge)，让我们难以辨别，我们可以让不同的用户显示不同的右下小图标，数字图标就是不错的选择，我们来看看如何修改</p><p><code>frameworks/base/core/java/android/app/ApplicationPackageManager.java</code>的getBadgeResIdForUser方法，返回一个Drawable资源id，作为子用户App的右下小图标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBadgeResIdForUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return the framework-provided badge.</span></span><br><span class="line">    <span class="keyword">if</span> (isManagedProfile(userId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> com.android.internal.R.drawable.ic_corp_icon_badge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个图标是要在右下角的，所以在做图标的时候，要做一张大的图标，它的右下角放着要显示的小图标，其余部分以透明填充。做好图标后要生成svg格式，用Android Studio以Vector Assets导入，大小64x64，导入成功会在项目的res/drawable生成drawable资源文件，把资源文件替换到<code>frameworks/base/core/res/res/drawable/ic_corp_icon_badge.xml</code>，并在<code>frameworks/base/core/res/res/values/symbols.xml</code>添加对drawable文件的声明</p><h1 id="9-在最新任务列表出现多开应用"><a href="#9-在最新任务列表出现多开应用" class="headerlink" title="9. 在最新任务列表出现多开应用"></a>9. 在最新任务列表出现多开应用</h1><p>默认情况下，最近任务列表是不会出现多开应用的。</p><p>在<code>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</code>的getRecentTasks方法中，有一段校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; recentsCount &amp;&amp; maxNum &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">    TaskRecord tr = mRecentTasks.get(i);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">if</span> (!tr.mUserSetupComplete) &#123;</span><br><span class="line">         <span class="comment">// Don&#x27;t include task launched while user is not done setting-up.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS,</span><br><span class="line">                     <span class="string">&quot;Skipping, user setup not complete: &quot;</span> + tr);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    res.add(rti);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将这段校验注释掉，tr是<code>frameworks/base/services/core/java/com/android/server/am/TaskRecord.java</code>类实例，mUserSetupComplete赋值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mUserSetupComplete = Settings.Secure.getIntForUser(mService.mContext.getContentResolver(),</span><br><span class="line">        USER_SETUP_COMPLETE, <span class="number">0</span>, userId) != <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="10-修改多开应用最近任务的名称"><a href="#10-修改多开应用最近任务的名称" class="headerlink" title="10. 修改多开应用最近任务的名称"></a>10. 修改多开应用最近任务的名称</h1><p>子用户默认会在最近任务的应用名称前加上”工作”这两个字，语言是英文会显示”Work”，如果想隐藏它们</p><p>中文：</p><p><code>frameworks/base/core/res/res/values-zh-rCN/strings.xml</code></p><p>英文：</p><p><code>frameworks/base/core/res/res/values/strings.xml</code></p><p>修改<code>managed_profile_label_badge</code>字段，去掉”工作”或者”Work”即可。</p><h1 id="11-修改卸载时的提示文本"><a href="#11-修改卸载时的提示文本" class="headerlink" title="11. 修改卸载时的提示文本"></a>11. 修改卸载时的提示文本</h1><p>如果是多开应用，卸载时提示的文本和主用户是不一样的，如果需要修改，则修改下面的文件</p><p>中文：</p><p><code>packages/apps/PackageInstaller/res/values-zh-rCN/strings.xml</code></p><p>英文：</p><p><code>packages/apps/PackageInstaller/res/values/strings.xml</code></p><p>修改<code>uninstall_application_text_user</code>字段的值</p><h1 id="12-参考"><a href="#12-参考" class="headerlink" title="12. 参考"></a>12. 参考</h1><p><a href="https://mp.weixin.qq.com/s/CeoijS42tkNLejkHw0waOw">Android 多用户 —— 从入门到应用分身 (上)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-准备&quot;&gt;&lt;a href=&quot;#1-准备&quot; class=&quot;headerlink&quot; title=&quot;1. 准备&quot;&gt;&lt;/a&gt;1. 准备&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/multi-app/sample.png&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;p&gt;把某</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hook Java API以获得MD5计算前数据</title>
    <link href="http://luoyesiqiu.github.io/2021/03/20/hook%20Java%20API%E4%BB%A5%E8%8E%B7%E5%BE%97MD5%E8%AE%A1%E7%AE%97%E5%89%8D%E6%95%B0%E6%8D%AE/"/>
    <id>http://luoyesiqiu.github.io/2021/03/20/hook%20Java%20API%E4%BB%A5%E8%8E%B7%E5%BE%97MD5%E8%AE%A1%E7%AE%97%E5%89%8D%E6%95%B0%E6%8D%AE/</id>
    <published>2021-03-20T14:29:24.000Z</published>
    <updated>2021-03-21T16:03:09.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。<sup>[1]<sup></p><p>有些人把MD5列为加密算法，这其实是不正确的，因为MD5计算本身就是不可逆的。</p><h2 id="Java实现MD5散列计算"><a href="#Java实现MD5散列计算" class="headerlink" title="Java实现MD5散列计算"></a>Java实现MD5散列计算</h2><p>在Java中，我们用对数据进行MD5计算，代码大概是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String md5 = md5(<span class="string">&quot;luoyesiqiu&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(md5);</span><br><span class="line">        System.out.println(md5.substring(<span class="number">8</span>,<span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(<span class="keyword">byte</span>[] input)</span></span>&#123;</span><br><span class="line">        StringBuilder md5 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest messageDigest = MessageDigest.getInstance(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buf = messageDigest.digest(input);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : buf)&#123;</span><br><span class="line">                <span class="keyword">int</span> val = b;</span><br><span class="line">                <span class="keyword">if</span>(val &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    val += <span class="number">256</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String hex = String.format(<span class="string">&quot;%02x&quot;</span>,val);</span><br><span class="line">                md5.append(hex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> md5.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码会输出32位的MD5值和16位的MD5值，16位MD5值是从32位中截取的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10ff0971d5ce668c3a9c20a8c96ba43e</span><br><span class="line">d5ce668c3a9c20a8</span><br></pre></td></tr></table></figure><h2 id="分析和实现"><a href="#分析和实现" class="headerlink" title="分析和实现"></a>分析和实现</h2><p>众所周知，MD5计算是不可逆的。如果，我们想要得到MD5计算前的数据该怎么办？想得到MD5计算前的数据，我们可以Hook呀！Hook <code>MessageDigest</code>类的<code>digest</code>方法，这个方法输入要计算的数据，返回一个计算的结果，只要Hook这个方法就能得到MD5计算前的数据和计算后的数据了，完美！Hook工具这里用的<a href="https://www.frida.re/">frida</a>。</p><p>在frida中，想要Hook，要用JavaScript写代码逻辑，写法可以参考我以前的博文：<a href="https://www.cnblogs.com/luoyesiqiu/p/10718997.html">frida的用法–Hook Java代码篇</a></p><h3 id="Hook代码"><a href="#Hook代码" class="headerlink" title="Hook代码"></a>Hook代码</h3><p><code>MessageDigest</code>类的<code>digest</code>方法有两个重载方式，我们把它们都给Hook了。</p><p>这里创建一个名为hookMD5.js的文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> algorithm = <span class="string">&#x27;MD5&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Java.available)</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> MessageDigest= Java.use(<span class="string">&#x27;java.security.MessageDigest&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> digest1 = MessageDigest.digest.overload(<span class="string">&quot;[B&quot;</span>,<span class="string">&quot;int&quot;</span>,<span class="string">&quot;int&quot;</span>);</span><br><span class="line">digest1.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">buf,offset,len</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> ret = digest2.call(<span class="built_in">this</span>,buf);</span><br><span class="line">parseIn(<span class="built_in">this</span>,buf);</span><br><span class="line">parseOut(<span class="built_in">this</span>,ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> digest2 = MessageDigest.digest.overload(<span class="string">&quot;[B&quot;</span>);</span><br><span class="line">digest2.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">buf</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> ret = digest2.call(<span class="built_in">this</span>,buf);</span><br><span class="line">parseIn(<span class="built_in">this</span>,buf);</span><br><span class="line">parseOut(<span class="built_in">this</span>,ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseIn</span>(<span class="params">digest,input</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> Integer= Java.use(<span class="string">&#x27;java.lang.Integer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">String</span>= Java.use(<span class="string">&#x27;java.lang.String&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(digest.getAlgorithm() != algorithm)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;original:&quot;</span>+<span class="built_in">String</span>.$new(input));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(e)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(parseHex(input));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseOut</span>(<span class="params">digest,ret</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> Integer= Java.use(<span class="string">&#x27;java.lang.Integer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">String</span>= Java.use(<span class="string">&#x27;java.lang.String&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;ret.length;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> val = ret[i];</span><br><span class="line"><span class="keyword">if</span>(val &lt; <span class="number">0</span>)&#123;</span><br><span class="line">val += <span class="number">256</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str = Integer.toHexString(val);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">String</span>.$new(str).length()==<span class="number">1</span>)&#123;</span><br><span class="line">str = <span class="string">&quot;0&quot;</span> + str;</span><br><span class="line">&#125;</span><br><span class="line">result += str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(digest.getAlgorithm()==algorithm)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(digest.getAlgorithm() + <span class="string">&quot;(32):&quot;</span> + result);</span><br><span class="line"><span class="built_in">console</span>.log(digest.getAlgorithm() + <span class="string">&quot;(16):&quot;</span> + result.substring(<span class="number">8</span>,<span class="number">24</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHex</span>(<span class="params">input</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> Integer= Java.use(<span class="string">&#x27;java.lang.Integer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> byte_array = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j&lt;input.length;j++)&#123;</span><br><span class="line"><span class="keyword">var</span> hex = Integer.toHexString(input[j]);</span><br><span class="line"><span class="keyword">if</span>(hex.length == <span class="number">1</span>)&#123;</span><br><span class="line">hex = <span class="string">&quot;0&quot;</span> + hex;</span><br><span class="line">&#125;</span><br><span class="line">byte_array += hex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;original(hex):&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> pair = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> hex_table = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>;k&lt;byte_array.length;k++)&#123;</span><br><span class="line">pair += byte_array.charAt(k);</span><br><span class="line"><span class="keyword">if</span>((k+<span class="number">1</span>)%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">pair += <span class="string">&quot; &quot;</span></span><br><span class="line">hex_table += pair;</span><br><span class="line">pair = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((k+<span class="number">1</span>)%<span class="number">32</span> == <span class="number">0</span>)&#123;</span><br><span class="line">hex_table += <span class="string">&quot;\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hex_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好后注入到目标进程：</p><p>frida -U -l hookMD5.js com.xxx.xxx</p><blockquote><p>注：-U代表对USB设备注入；<code>com.xxxx.xxxx</code>是要Hook的App包名</p></blockquote><p>Hook某App运行结果如下：</p><p><img src="/images/md5/md5hook.png" alt="result"></p><p>上面的frida脚本，不仅可以Hook MD5算法流程，还可以Hook SHA家族的散列算法流程，修改Javascript脚本开头的<code>algorithm</code>变量即可达到目的，读者可以自行尝试。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://zh.wikipedia.org/wiki/MD5">https://zh.wikipedia.org/wiki/MD5</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（</summary>
      
    
    
    
    
  </entry>
  
</feed>
